import the third party libraries. also import silver modules too.


# im not so sure about the arg because it prevents us from passing our own fields in a orthogonal way
# we have the functions load in this .o global; imports must be compiled seperately in silver (makes sense to allow each their own global)

# <- if no string arg is given to import it may still know the top module importing
module zlib {
	# this is less tokens
	import as i {
		name: 'zlib' # import would use zlib if undefined, since thats the module def name at top
		deps: [c_lib, another] # run these in this order so it knows how to build them
		src:  'https://zlib.org/repo'
	}


	#
	void func() {
		# functions are variables and types; if assigning to another you may omit the name
		# isolated no-op functions that do not call themselves would have to be warned about
		void func2() {
		}
	}
	
}



/*

    // define a struct type in the custom language
    LLVMTypeRef structType = LLVMStructCreateNamed(i->llvm_context, "MyStruct");
    LLVMTypeRef elementTypes[] = {
        LLVMInt32Type(), LLVMInt32Type(),
        LLVMInt32Type(), LLVMInt32Type()
    };
    LLVMStructSetBody(structType, elementTypes, 4, 0);

    // create debug info for struct
    LLVMMetadataRef memberDebugTypes[4];
    for (int m = 0; m < 4; m++) {
        memberDebugTypes[m] = LLVMDIBuilderCreateBasicType(
            i->dbg, "int", 3, 32, 
            (LLVMDWARFTypeEncoding)0x05,
            (LLVMDIFlags)0); /// signed 0x05 (not defined somehwo) DW_ATE_signed
    }

    LLVMMetadataRef structDebugType = LLVMDIBuilderCreateStructType(
        i->dbg, i->compile_unit, "MyStruct", 8, i->file, 1, 
        128, 32, 0, NULL, 
        memberDebugTypes, 4, 0, NULL, "", 0);

    // create a function and access the struct member
    map args = new(map);
    call(args, set, str("argc"),
        new(dim, module, a, context, a->defs, type, module_def(a, "i32"),  depth, 0));
    call(args, set, str("argv"),
        new(dim, module, a, context, a->defs, type, module_def(a, "cstr"), depth, 1));
    dim rtype = new(dim,
        module, a, context, a->defs,
        type, call(a->defs, get, str("i32")));
    type  fn = new(type,
        name,  "main",
        module, a,
        rtype,  rtype,
        args,   args);

    //call(fn, from_tokens) -- lets import parse_statements -> parse_expression
    LLVMBuilderRef builder = LLVMCreateBuilder();

    /// this is 'finalize' for a method, after we call parse on module, parsing all members in each class or struct
    // Create a pointer to MyStruct (simulate `self` in your custom language)
    LLVMValueRef structPtr = LLVMBuildAlloca(builder, structType, "self");

    // Create debug info for the local variable
    LLVMMetadataRef localVarDIType = LLVMDIBuilderCreatePointerType(
        i->dbg, structDebugType, 64, 0, 0, "MyStruct*", 9);
    LLVMMetadataRef localVarDbgInfo = LLVMDIBuilderCreateAutoVariable(
        i->dbg, type_dbg(fn), "self", 4, i->file, 2, localVarDIType, 1, 0, 0);
    
    LLVMDIBuilderInsertDeclareAtEnd(
        i->dbg,
        structPtr,
        localVarDbgInfo,
        LLVMDIBuilderCreateExpression(i->dbg, NULL, 0),
        LLVMDIBuilderCreateDebugLocation(i->llvm_context, 2, 0, type_dbg(fn), NULL),
        LLVMGetInsertBlock(builder));

    // Set values for struct members
    symbol memberNames[]  = { "member1", "member2", "member3", "member4" };
    int    memberValues[] = { 42, 44, 46, 48 };
    LLVMTypeRef int32Type = LLVMInt32TypeInContext(i->llvm_context);

    for (int m = 0; m < 4; m++) {
        LLVMValueRef memberPtr = LLVMBuildStructGEP2(builder, structType, structPtr, m, memberNames[m]);
        LLVMBuildStore(builder, LLVMConstInt(int32Type, memberValues[m], 0), memberPtr);

        // Create debug info for each member
        LLVMMetadataRef memberDebugInfo = LLVMDIBuilderCreateAutoVariable(
            i->dbg, type_dbg(fn), memberNames[m], strlen(memberNames[m]),
            i->file, m + 3, memberDebugTypes[m], 0, 0, 0);
        LLVMDIBuilderInsertDeclareAtEnd(i->dbg, memberPtr, memberDebugInfo,
            LLVMDIBuilderCreateExpression(i->dbg, NULL, 0),
            LLVMDIBuilderCreateDebugLocation(i->llvm_context, m + 3, 0, type_dbg(fn), NULL),
            LLVMGetInsertBlock(builder));

        isilver(a, set_line, 3 + m, 0);
    }
    isilver(a, set_line, 7, 0);

    // Return from main
    LLVMBuildRet(builder, LLVMConstInt(LLVMInt32Type(), 0, false));
    LLVMDIBuilderFinalize(i->dbg);
*/