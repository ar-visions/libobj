#define silver_intern  intern(silver)
#include <silver>
#include <import>

#define string(...) new(string, ## __VA_ARGS__) 

#define isilver(M,...) silver_##M(mod,    ## __VA_ARGS__)
#define    idef(M,...)    def_##M(ident,  ## __VA_ARGS__)
#define    idim(M,...)    member_##M(member, ## __VA_ARGS__)

#undef  peek
#define tok(...)     call(mod->tokens, __VA_ARGS__) /// no need to pass around the redundant tokens args when the class supports a stack

static array operators;

void init() {
    operators = map_of( /// ether quite needs some operator bindings, and resultantly ONE interface to use them
        "+",        str("add"),
        "-",        str("sub"),
        "*",        str("mul"),
        "/",        str("div"),
        "||",       str("or"),
        "&&",       str("and"),
        "^",        str("xor"),
        ">>",       str("right"),
        "<<",       str("left"),
        ":",        str("assign"),
        "=",        str("assign"),
        "+=",       str("assign_add"),
        "-=",       str("assign_sub"),
        "*=",       str("assign_mul"),
        "/=",       str("assign_div"),
        "|=",       str("assign_or"),
        "&=",       str("assign_and"),
        "^=",       str("assign_xor"),
        ">>=",      str("assign_right"),
        "<<=",      str("assign_left"),
        "==",       str("compare_equal"),
        "!=",       str("compare_not"),
        "%=",       str("mod_assign"),
        "is",       str("is"),
        "inherits", str("inherits"), null
    );
}

module_init(init)

string type_key(LLVMTypeRef type) {
    return format("%p", type);
}

void silver_print_tokens(silver mod) {
    print("tokens: %o %o %o %o %o ...", 
        read(mod->tokens, 0), read(mod->tokens, 1),
        read(mod->tokens, 2), read(mod->tokens, 3),
        read(mod->tokens, 4), read(mod->tokens, 5));
}

type silver_def(silver mod, string key) {
    return get(mod->defs, key);
}

member silver_member(silver mod, string key) {
    return get(mod->members, key);
}

bool silver_build_dependencies(silver mod) {
    each(mod->imports, Import, im) {
        process(im);
    }
    return true;
}

LLVMValueRef silver_build_statements(silver mod) {
    LLVMValueRef result = null;
    return result;
}

LLVMValueRef silver_parse_expression(silver mod);

bool dim_type_is(member member, type t) {
    type tt = member->type;
    while (tt) {
        if (t == tt) return true;
        tt = tt->origin;
    }
    return false;
}

/// no LLVM here, it goes into ether.
/// move over what is not in ether

node silver_parse_return(silver mod) {
    member rtype = lookup(mod->e, str("#rtype")); // stored when we start building function
    type  t_void  = get(mod->defs, str("void"));
    bool is_void = dim_type_is(rtype, t_void);
    tok (consume);
    return (mod->builder, isilver(parse_expression));
}

LLVMValueRef silver_parse_break(silver mod) {
    tok(consume);
    LLVMValueRef vr = null;
    return null;
}

LLVMValueRef silver_parse_for(silver mod) {
    tok(consume);
    LLVMValueRef vr = null;
    return null;
}

LLVMValueRef silver_parse_while(silver mod) {
    tok(consume);
    LLVMValueRef vr = null;
    return null;
}

LLVMValueRef silver_parse_if_else(silver mod) {
    tok(consume);
    LLVMValueRef vr = null;
    return null;
}

LLVMValueRef silver_parse_do_while(silver mod) {
    tok(consume);
    LLVMValueRef vr = null;
    return null;
}

type preferred_type(silver mod, type t0, type t1) {
    if (t0 == t1) return t0;
    bool f0 = t0->mdl == model_f32 || t0->mdl == model_f64;
    bool f1 = t1->mdl == model_f32 || t1->mdl == model_f64;
    if (f0) {
        if (f1)
            return (t1->mdl == model_f64) ? t1 : t0;
        return t0;
    }
    if (f1)
        return t1;
    if (t0->mdl > t1->mdl)
        return t0;
    return t1;
}

typedef LLVMValueRef(*builder_fn)(silver, type, type, type, LLVMValueRef, LLVMValueRef);
typedef LLVMValueRef(*parse_fn)(silver, symbol, symbol, builder_fn, builder_fn);

#define resolve_type(llvm_type_ref) isilver(type_from_llvm, llvm_type_ref);

LLVMValueRef parse_ops(
        silver mod, parse_fn descent, symbol op0, symbol op1, builder_fn b0, builder_fn b1) {
    LLVMValueRef left = descent(mod, op0, op1, b0, b1);
    while(tok(next_is, op0) || tok(next_is, op1)) {
        tok(consume);
        LLVMValueRef right = descent(mod, op0, op1, b0, b1);
        bool         use0 = tok(next_is, op0);
        symbol    op_code = use0 ? op0 : op1;
        builder_fn    bfn = use0 ? b0  : b1;

        assert (contains(mod->operators, str(op_code)), "op (%s) not registered", op_code);
        string  op_name   = get(mod->operators, str(op_code));
        type     left_type = resolve_type(left);
        member     method    = get(left_type->members, op_name);
        type     r_left    = resolve_type(LLVMTypeOf(left));
        type     r_right   = resolve_type(LLVMTypeOf(right));

        if (method) { /// and convertible(r_right, method.args[0].type):
            LLVMValueRef args[2] = { left, right };
            left = LLVMBuildCall2(mod->builder, method->type->def, method->value, args, 2, "operator");
        } else {
            def  type_out = preferred_type(mod, r_left, r_right); /// should work for primitives however we must handle more in each
            left          = bfn(mod, type_out, r_left, r_right, left, right); 
        }
    }
    return left;
}

LLVMValueRef op_is(silver mod, member member, def t0, def t1, LLVMValueRef v0,  LLVMValueRef v1) {
    assert(member->def->mdl == model_bool, "inherits operator must return a boolean type");
    assert(LLVMGetTypeKind(LLVMTypeOf(v0))  == LLVMFunctionTypeKind &&
           LLVMGetTypeKind(LLVMTypeOf(v1)) == LLVMFunctionTypeKind, 
           "is operator expects function type or initializer");
    bool equals = t0 == t1;
    return LLVMConstInt(LLVMInt1Type(), equals, 0);
}

LLVMValueRef op_inherits(silver mod, member member, def t0, def t1, LLVMValueRef v0,  LLVMValueRef v1) {
    assert(member->def->mdl == model_bool, "inherits operator must return a boolean type");
    assert(LLVMGetTypeKind(LLVMTypeOf(v0))  == LLVMFunctionTypeKind &&
           LLVMGetTypeKind(LLVMTypeOf(v1)) == LLVMFunctionTypeKind, 
           "is operator expects function type or initializer");
    bool      equals = t0 == t1;
    LLVMValueRef yes = LLVMConstInt(LLVMInt1Type(), 1, 0);
    LLVMValueRef no  = LLVMConstInt(LLVMInt1Type(), 0, 0);
    def cur = t0;
    while (cur) {
        if (cur == t1)
            return yes;
        cur = cur->origin;
    }
    return no;
}

LLVMValueRef op_add(silver mod, member member, def t0, def t1, LLVMValueRef v0,  LLVMValueRef v1) {
    return LLVMBuildAdd(mod->builder, v0, v1, "add");
}

LLVMValueRef op_sub(silver mod, member member, def t0, def t1, LLVMValueRef v0,  LLVMValueRef v1) {
    return LLVMBuildSub(mod->builder, v0, v1, "add");
}

LLVMValueRef op_mul(silver mod, member member, def t0, def t1, LLVMValueRef v0,  LLVMValueRef v1) {
    assert (false, "op_mul: implement more design here");
    return null;
}

LLVMValueRef op_div(silver mod, member member, def t0, def t1, LLVMValueRef v0,  LLVMValueRef v1) {
    assert (false, "op_div: implement more design here");
    return null;
}

LLVMValueRef op_eq(silver mod, member member, def t0, def t1, LLVMValueRef v0,  LLVMValueRef v1) {
    bool    i0 = t0->mdl >= model_bool && t0->mdl <= model_i64;
    bool    f0 = t0->mdl >= model_f32  && t0->mdl <= model_f64;
    if      (i0) return LLVMBuildICmp(mod->builder, LLVMIntEQ,   v0, v1, "eq-i");
    else if (f0) return LLVMBuildFCmp(mod->builder, LLVMRealOEQ, v0, v1, "eq-f");
    else {
        assert (false, "op_eq: implement more design here");
        return null;
    }
}

LLVMValueRef op_not_eq(silver mod, member member, def t0, def t1, LLVMValueRef v0,  LLVMValueRef v1) {
    bool    i0 = t0->mdl >= model_bool && t0->mdl <= model_i64;
    bool    f0 = t0->mdl >= model_f32  && t0->mdl <= model_f64;
    if      (i0) return LLVMBuildICmp(mod->builder, LLVMIntNE,   v0, v1, "not-eq-i");
    else if (f0) return LLVMBuildFCmp(mod->builder, LLVMRealONE, v0, v1, "not-eq-f");
    else {
        assert (false, "op_not_eq: implement more design here");
        return null;
    }
}

LLVMValueRef silver_parse_primary(silver mod);

LLVMValueRef silver_parse_eq  (silver mod) { return parse_ops(mod, silver_parse_primary, "==", "!=",         op_eq,  op_not_eq); }
LLVMValueRef silver_parse_is  (silver mod) { return parse_ops(mod, silver_parse_eq,      "is", "inherits",   op_is,  op_is);     }
LLVMValueRef silver_parse_mult(silver mod) { return parse_ops(mod, silver_parse_is,      "*",  "/",          op_is,  op_is);     }
LLVMValueRef silver_parse_add (silver mod) { return parse_ops(mod, silver_parse_mult,    "+",  "-",          op_add, op_sub);    }

LLVMValueRef silver_parse_expression(silver mod) {
    mod->expr_level++;
    LLVMValueRef vr = isilver(parse_add);
    mod->expr_level--;
    return vr;
}

def silver_read_def(silver mod) {
    string name = tok(next_alpha); // Read the type to cast to
    if (!name) return null;
    return get(mod->defs, name);
}

LLVMValueRef silver_parse_primary(silver mod) {
    Token t = tok(peek);

    // handle the logical NOT operator (e.g., '!')
    if (tok(next_is, "!") || tok(next_is, "not")) {
        tok(consume); // Consume '!' or 'not'
        LLVMValueRef expr = silver_parse_expression(mod); // Parse the following expression
        return LLVMBuildNot(mod->builder, expr, "logical_not");
    }

    // bitwise NOT operator
    if (tok(next_is, "~")) {
        tok(consume); // Consume '~'
        LLVMValueRef expr = silver_parse_expression(mod);
        return LLVMBuildNot(mod->builder, expr, "bitwise_not");
    }

    // 'typeof' operator
    if (tok(next_is, "typeof")) {
        tok(consume); // Consume 'typeof'
        assert(tok(next_is, "["), "Expected '[' after 'typeof'");
        tok(consume); // Consume '['
        LLVMValueRef type_ref = silver_parse_expression(mod); // Parse the type expression
        assert(tok(next_is, "]"), "Expected ']' after type expression");
        tok(consume); // Consume ']'
        return type_ref; // Return the type reference
    }

    // 'cast' operator
    if (tok(next_is, "cast")) {
        tok(consume); // Consume 'cast'
        def cast_ident = isilver(read_def); // Read the type to cast to
        verify (cast_ident, "expected ident after cast");
        assert(tok(next_is, "["), "Expected '[' for cast");
        tok(consume); // Consume '['
        LLVMValueRef expr = silver_parse_expression(mod); // Parse the expression to cast
        tok(consume); // Consume ']'
        if (cast_ident) {
            return LLVMBuildCast(mod->builder, LLVMBitCast, cast_ident->type, expr, "explicit_cast");
        }
    }

    // 'ref' operator (reference)
    if (tok(next_is, "ref")) {
        tok(consume); // Consume 'ref'
        LLVMValueRef expr = silver_parse_expression(mod);
        return LLVMBuildLoad2(mod->builder, LLVMTypeOf(expr), expr, "ref_expr"); // Build the reference
    }

    // numeric constants
    object v_num = tok(next_numeric);
    if (v_num) {
        AType num_type = isa(v_num);
        if (num_type == typeid(i8))  return LLVMConstInt( LLVMInt8Type(),  *( i8*)v_num, 0);
        if (num_type == typeid(i16)) return LLVMConstInt(LLVMInt16Type(),  *(i16*)v_num, 0);
        if (num_type == typeid(i32)) return LLVMConstInt(LLVMInt32Type(),  *(i32*)v_num, 0);
        if (num_type == typeid(i64)) return LLVMConstInt(LLVMInt64Type(),  *(i64*)v_num, 0);
        if (num_type == typeid(u8))  return LLVMConstInt( LLVMInt8Type(),  *( u8*)v_num, 0);
        if (num_type == typeid(u16)) return LLVMConstInt(LLVMInt16Type(),  *(u16*)v_num, 0);
        if (num_type == typeid(u32)) return LLVMConstInt(LLVMInt32Type(),  *(u32*)v_num, 0);
        if (num_type == typeid(u64)) return LLVMConstInt(LLVMInt64Type(),  *(u64*)v_num, 0);
        if (num_type == typeid(f32)) return LLVMConstInt(LLVMFloatType(),  *(f32*)v_num, 0);
        if (num_type == typeid(f64)) return LLVMConstInt(LLVMDoubleType(), *(f64*)v_num, 0);
        assert (false, "numeric literal not handling primitive: %s", num_type->name);
    }

    // strings
    string str_token = tok(next_string);
    if (str_token)
        return LLVMBuildGlobalStringPtr(mod->builder, str_token->chars, "str");

    // boolean values
    object v_bool = tok(next_bool);
    if (v_bool)
        return LLVMConstInt(LLVMInt1Type(), *(bool*)v_bool, 0);

    // parenthesized expressions
    if (tok(next_is, "[")) {
        tok(consume);
        LLVMValueRef expr = silver_parse_expression(mod); // Parse the expression
        assert(tok(next_is, "]"), "Expected closing parenthesis");
        tok(consume);
        return expr;
    }

    // handle identifiers (variables or function calls)
    string ident = tok(next_alpha);
    if (ident) {
        member member = silver_member_stack_lookup(mod, ident); // Look up variable
        // if its a primitive, we will want to get its value unless we are referencing (which we handle differently above!)
        LLVMValueRef vr = member->value;
        if (member->def->mdl >= model_bool && member->def->mdl <= model_f64) {
            LLVMTypeRef type = LLVMTypeOf(vr);
            print ("vr type = %s", LLVMPrintTypeToString(LLVMTypeOf(vr)));
            verify (LLVMGetTypeKind(type) == LLVMPointerTypeKind, "expected member address");
            vr = LLVMBuildLoad2(mod->builder, member->def->type, vr, "load-member");
        }
        return vr;
    }

    fault("unexpected token %o in primary expression", tok(peek));
    return null;
}

LLVMValueRef silver_parse_assignment(silver mod, member member, string op) {
    verify(!member->cached || !member->is_const, "member %o is a constant", member->name);
    string         op_name = Token_op_name(op);
    member            method  = get(member->def->members, op_name);
    LLVMValueRef   res     = null;
    LLVMBuilderRef B       = mod->builder;
    LLVMValueRef   L       = member->value;
    LLVMValueRef   R       = isilver(parse_expression);

    if (method) {
        LLVMValueRef args[2] = { L, R };
        res = LLVMBuildCall2(B, method->type, method->value, args, 2, "assign");
    } else {
        member->is_const = eq(op, "=");
        bool e = member->is_const;
        if (e || eq(op, ":"))  res = LLVMBuildStore(B, R, L);
        else if (eq(op, "+=")) res = LLVMBuildAdd  (B, R, L, "assign-add");
        else if (eq(op, "-=")) res = LLVMBuildSub  (B, R, L, "assign-sub");
        else if (eq(op, "*=")) res = LLVMBuildMul  (B, R, L, "assign-mul");
        else if (eq(op, "/=")) res = LLVMBuildSDiv (B, R, L, "assign-div");
        else if (eq(op, "%=")) res = LLVMBuildSRem (B, R, L, "assign-mod");
        else if (eq(op, "|=")) res = LLVMBuildOr   (B, R, L, "assign-or"); 
        else if (eq(op, "&=")) res = LLVMBuildAnd  (B, R, L, "assign-and");
        else if (eq(op, "^=")) res = LLVMBuildXor  (B, R, L, "assign-xor");
        else fault("unsupported operator: %o", op);
    }
    /// update member's value_ref
    //member->value_ref = res;
    if (eq(op, "=")) member->is_const = true;
    return member->value;
}

LLVMValueRef silver_parse_function_call(silver mod, member fn) {
    bool allow_no_paren = mod->expr_level == 1; /// remember this decision? ... var args
    bool expect_end_br  = false;
    function def        = fn->def;
    assert (def, "no definition found for function member %o", fn->name);
    int  arg_count      = count(def->args);
    
    if (tok(next_is, "[")) {
        tok(consume);
        expect_end_br = true;
    } else if (!allow_no_paren)
        fault("expected [ for nested call");

    vector v_args = new(vector, alloc, 32, type, typeid(LLVMValueRef));
    int arg_index = 0;
    LLVMValueRef values[32];

    member last_arg = null;
    while(arg_index < arg_count || def->va_args) {
        member          arg      = arg_index < def->args->count ? idx_1(def->args, sz, arg_index) : null;
        LLVMValueRef expr     = isilver(parse_expression);
        LLVMTypeRef  arg_type = arg ? arg->type : null;
        LLVMTypeRef  e_type   = LLVMTypeOf(expr); /// this should be 'someting' member

        if (LLVMGetTypeKind(e_type) == LLVMPointerTypeKind) {
            expr = LLVMBuildLoad2(mod->builder,
                arg ? arg->type : LLVMPointerType(LLVMInt8Type(), 0), expr, "load-arg");
        }

        if (arg_type && e_type != arg_type)
            expr = LLVMBuildBitCast(mod->builder, expr, arg_type, "bitcast");
        
        print("argument %i: %s", arg_index, LLVMPrintValueToString(expr));

        //push(v_args, &expr);
        values[arg_index] = expr;
        arg_index++;
        if (tok(next_is, ",")) {
            tok(consume);
            continue;
        } else if (tok(next_is, "]")) {
            verify (arg_index >= arg_count, "expected %i args", arg_count);
            break;
        } else {
            if (arg_index >= arg_count)
                break;
        }
    }
    if (expect_end_br) {
        verify(tok(next_is, "]"), "expected ] end of function call");
        tok(consume);
    }
    return LLVMBuildCall2(
        mod->builder, fn->type, fn->value, values, arg_index, "fn-call");
}

LLVMValueRef silver_parse_statement(silver mod) {
    Token t = tok(peek);
    if (tok(next_is, "return")) return isilver(parse_return);
    if (tok(next_is, "break"))  return isilver(parse_break);
    if (tok(next_is, "for"))    return isilver(parse_for);
    if (tok(next_is, "while"))  return isilver(parse_while);
    if (tok(next_is, "if"))     return isilver(parse_if_else);
    if (tok(next_is, "do"))     return isilver(parse_do_while);

    map members = isilver(top_members);
    member member  = silver_read_member(mod, members, true);
    if (member) {
        print("%s member: %o %o", member->cached ? "existing" : "new", member->def->name, member->name);
        if (member->def->mdl == model_function) {
            if      (member->depth == 1) return member->value;
            else if (member->depth == 0) return isilver(parse_function_call, member);
            fault ("invalid operation");
        } else {
            string assign = tok(next_assign);
            if    (assign) return isilver(parse_assignment, member, assign);
        }
    }
    fault ("implement"); /// implement as we need them
    return null;
}

LLVMValueRef silver_parse_statements(silver mod) {
    map  members    = isilver(push_member_stack);
    bool multiple   = tok(next_is, "[");
    if  (multiple)    tok(consume);
    int  depth      = 1;
    LLVMValueRef vr = null;
    ///
    while(tok(cast_bool)) {
        if(multiple && tok(next_is, "[")) {
            depth += 1;
            isilver(push_member_stack);
            tok(consume);
        }
        print("next statement origin: %o", tok(peek));
        vr = isilver(parse_statement);
        if(!multiple) break;
        if(tok(next_is, "]")) {
            if (depth > 1)
                isilver(pop_member_stack);
            tok(next);
            if ((depth -= 1) == 0) break;
        }
    }
    isilver(pop_member_stack);
    return vr;
}

static void silver_scope_push(silver mod, LLVMMetadataRef meta_ref) {
    push    (mod->scope_stack, meta_ref);
    mod->scope = meta_ref;
}

static void silver_scope_pop(silver mod) {
    pop     (mod->scope_stack);
    mod->scope = len(mod->scope_stack) ? last(mod->scope_stack) : null;
}

void silver_parse_top(silver mod) {
    while (tok(cast_bool)) {
        if (tok(next_is, "import")) {
            Import import  = new(Import, mod, mod, tokens, mod->tokens);
            push(mod->imports, import);
            continue;
        } else if (tok(next_is, "class")) {
            verify (false, "not implemented");
            //EClass def = new(EClass, tokens, tokens);
            //call(mod->defs, set, def->name, def);
            continue;
        } else {
            silver_print_tokens(mod);
            member member = silver_read_member(mod, mod->defs, false);
            string key = member->name ? member->name : (string)format("$m%i", count(mod->defs));
            set(mod->members, key, member);
        }
    }
}

void silver_build_function(silver mod, function fn) {

    fn->function_meta = functionMeta;
    fn->entry    = entry;
    //if (fn->body) {
        //isilver (scope_push, fn->function_meta); <- BUG: funciton_meta cannot be used as a 'scope'
        tokens  (push_state, fn->body->tokens, fn->body->cursor);
        LLVMPositionBuilderAtEnd(mod->builder, fn->entry);
        map      members = isilver(push_member_stack);
        concat  (members, fn->args);
        set     (members, str("#rtype"), fn->rtype);
        //LLVMBuildRetVoid(mod->builder);
        //LLVMTypeRef type = LLVMInt64Type();
        //LLVMBuildRet    (mod->builder, LLVMConstInt(type, 1, 0));
        isilver (parse_statements);
        isilver (pop_member_stack);
        tokens  (pop_state, false);
        //isilver (scope_pop);
    //} else {
    //    fault ("expected fn body");
    //}
}

void silver_include(silver mod, string include) {
    string   install   = format("%o/include", mod->install);
    path     full_path = null;
    symbol   ipaths[]  = {
        install->chars,
        "/usr/include"
    };
    for (int i = 0; i < sizeof(ipaths) / sizeof(symbol); i++) {
        path r = form(path, "%s/%o", ipaths[i], include);
        if (exists(r)) {
            full_path = r;
            break;
        }
    }
    verify (full_path, "include path not found for %o", include);
    CXIndex index = clang_createIndex(0, 0);
    CXTranslationUnit unit = clang_parseTranslationUnit(
        index, full_path->chars, NULL, 0, NULL, 0, CXTranslationUnit_None);

    verify(unit, "unable to parse translation unit %o", include);
    
    CXCursor cursor = clang_getTranslationUnitCursor(unit);
    mod->current_include = include;
    //clang_visitChildren(cursor, visit, (CXClientData)mod);
    clang_disposeTranslationUnit(unit);
    clang_disposeIndex(index);
    mod->current_include = null;
}

void function_build(function fn);

// no llvm-based code in silver, replace with comments when needed
void silver_init(silver mod) {
    verify(mod->source, "mod name not set");

    mod->scope_stack   = new(array, alloc, 32, unmanaged, true);
    mod->member_stack  = new(array, alloc, 32);
    mod->members       = isilver(push_member_stack); /// our base members is the first stack item that we keep after building
    mod->imports       = new(array, alloc, 32);
    mod->source_path   = call(mod->source, directory);
    mod->source_file   = call(mod->source, filename);
    mod->libraries_used = new(array);
    mod->type_refs     = new(map, hsize, 64);
    mod->operators     = operators;

    cstr err = NULL;
    path  full_path = form(path, "%o/%o", mod->source_path, mod->source_file);
    verify(exists(full_path), "source (%o) does not exist", full_path);
    mod->builder = LLVMCreateBuilderInContext(mod->context);
    mod->tokens = new(tokens, file, full_path);

    isilver(define_primitives);
    isilver(parse_top);
    //isilver(include, str("stdio.h"));
    //isilver(build_dependencies);
    
    /// build into functions and class methods
    map base_members = isilver(top_members);
    pairs (mod->defs, e) {
        function def = e->value;
        /// create members out of included functions and external data (may make sense to do this directly)
        if (def->from_include && def->mdl == model_function)
            set(base_members, def->name, def->info);
    }
    pairs (mod->defs, e) {
        function def = e->value;
        // for each type def with a body to build
        if (def->mdl == model_function && !def->from_include) {
 
            isilver(build_function, def);
        }
    }
    isilver(pop_member_stack);
}

void silver_destructor(silver mod) {
    LLVMDisposeBuilder(mod->builder);
    LLVMDisposeDIBuilder(mod->dbg);
    LLVMDisposeModule(mod->module);
    LLVMContextDispose(mod->context);
    LLVMDisposeMessage(mod->target_triple);
}

void silver_write(silver mod) {
    // Finalize the debug builder (leave room for user to write additional functions after init)
    LLVMDIBuilderFinalize(mod->dbg);

    // Verify the module
    char *error = NULL;
    if (LLVMVerifyModule(mod->module, LLVMReturnStatusAction, &error)) {
        fprintf(stderr, "Error verifying mod->module: %s\n", error);
        LLVMDisposeMessage(error);
        exit(1);
    }

    // Optionally, write the module to a file
    if (LLVMPrintModuleToFile(mod->module, "output.ll", &error) != 0) {
        fprintf(stderr, "Error writing mod->module to file: %s\n", error);
        LLVMDisposeMessage(error);
        exit(1);
    }
}

void dim_bind(member member) {
    silver mod = member->mod;
    if (!tok(next_is, "["))
        return;
    tok(consume);
    member->wrap  = get(mod->defs, str("array"));
    member->shape = new(array); /// shape is there but not given data 
    if (!tok(next_is, "]")) {
        def wdef = isilver(read_def); // we are treating anything as a member
        if (wdef) {
            /// must be map
            for (;;) {
                push(member->shape, wdef);
                Token n = tok(peek);
                if (eq(n, ",")) {
                    wdef = isilver(read_def);
                    continue;
                }
                break;
            }
        } else {
            /// must be array
            for (;;) {
                i64 dim_size = 0;
                object n = tok(read_numeric);
                verify(n && isa(n) == typeid(i64), "expected integer");
                tok(consume);
                push(member->shape, A_i64(dim_size));
                Token next = tok(peek);
                if (eq(next, ",")) {
                    tok(consume);
                    continue;
                }
                break;
            }
        }
        verify (tok(next_is, "]"), "expected ] in type usage expression");
    }
    tok(consume);
}

void dim_allocate(member member, silver mod, bool create_debug) {
    LLVMTypeRef tr = member->type;
    print("tr = %s", LLVMPrintTypeToString(tr));
    member->value   = LLVMBuildAlloca(mod->builder, tr, "alloc-member");
    member->dbg     = LLVMDIBuilderCreateAutoVariable(
        mod->dbg,
        mod->scope,
        member->name->chars,
        member->name->len,
        mod->file,
        2,
        member->def->dbg,
        true, 0, 0);


    LLVMBasicBlockRef block = LLVMGetInsertBlock(mod->builder);
    LLVMValueRef      head  = LLVMGetFirstInstruction(block);

    verify (block && head, "LLVM is a block head");
    verify (head == member->value, "LLVM is a block head");
    // Now insert this variable into the IR, associating it with the debug metadata
    LLVMDIBuilderInsertDeclareBefore(
        mod->dbg,
        member->value,
        member->dbg,
        LLVMDIBuilderCreateExpression(mod->dbg, NULL, 0),
        LLVMDIBuilderCreateDebugLocation(mod->context, member->line, 0, mod->scope, NULL),  // Debug location
        head
    );
}

void dim_set_def(member member, def def) {
    if (member->def != def) {
        drop(member->def);
        member->def = hold(def);
    }
    if (member->def) {
        LLVMTypeRef t = member->def->type;
        if (member->depth > 0 && t == LLVMVoidType())
            t = LLVMInt8Type();
        for (int i = 0; i < member->depth; i++)
            t = LLVMPointerType(t, 0);
        member->type = t;
    } else {
        member->type = null;
    }
}

void dim_create_fn(member member) {
    silver mod = member->mod;
    map    members = member->context;
    verify (tok(next_is, "["), "expected function args");
    tokens (consume);
    map args = new(map, hsize, 8);
    int arg_index = 0;
    
    silver_print_tokens(mod);

    if (!tok(next_is, "]"))
        while (true) {
            member arg = silver_read_member(member->mod, member->def->members, false);
            verify (arg,       "member failed to read");
            verify (arg->name, "member name not set");
            if     (tok(next_is, "]")) break;
            verify (tok(next_is, ","), "expected separator");
            tokens (consume);
            set    (args, arg->name, arg);
            arg_index++;
        }
    num line = tok(line);
    tok(consume);
    member rtype_dim = new(member,
        mod,        member->mod,    def,        member->def,    line, line,
        depth,      member->depth,  shape,      member->shape,
        wrap,       member->wrap,   context,    members);
    function f_def = new(function,
        name,     str(member->name->chars),  mod,   member->mod,
        mdl,      model_function,       rtype,    rtype_dim,
        args,     args,                 info,     member);
    //assert(count(members, f_def->name) == 0, "duplicate member: %o", f_def->name);
    set (members, f_def->name, f_def);
    dim_set_def(member, f_def);
    array body = new(array, alloc, 32);
    verify (tok(next_is, "["), "expected function body");
    int depth = 0;
    do {
        Token   token = tok(next);
        verify (token, "expected end of function body ( too many ['s )");
        push   (body, token);
        if      (eq(token, "[")) depth++;
        else if (eq(token, "]")) depth--;
    } while (depth > 0);
    f_def->body = new(tokens, cursor, 0, tokens, body);
}

member silver_read_member(silver mod, map context, bool alloc) {
    /// we use alloc to obtain a value-ref by means of allocation inside a function body.
    /// if we are not there, then set false in that case.
    /// in that case, the value_ref should be set by the user to R-type or ARG-type
    tok(push_current);
    member member = null;

    print("dim_read:");
    silver_print_tokens(mod);

    string alpha = tok(next_alpha);
    if(alpha) {
        member = isilver(member_stack_lookup, alpha);
        if (member) {
            member->cached = true;
            return member;
        } else {
            tok(prev);
        }
    }
    member = new(member, mod, mod, context, context);
    
    if (tok(next_is, "static")) {
        tok(consume);
        member->is_static = true;
    }
    if (tok(next_is, "ref")) {
        tok(consume);
        member->depth = 1;
    }
    /// look for visibility (default is possibly provided)
    for (int m = 1; m < Visibility_type.member_count; m++) {
        type_member_t* enum_v = &Visibility_type.members[m];
        if (tok(next_is, enum_v->name)) {
            tok(consume);
            member->visibility = m;
            break;
        }
    }
    if (!member->is_static) {
        if (tok(next_is, "static")) {
            tok(consume);
            member->is_static = true;
        }
    }
    Token   n = tok(peek);
    def ident = isilver(read_def);
    if (!ident) {
        print("info: could not read type at position %o", tok(location));
        tok(pop_state, false); // we may 'info' here
        return null;
    }
    dim_set_def(member, ident);

    silver_print_tokens(mod);
    
    // may be [, or alpha-id  (its an error if its neither)
    if (tok(next_is, "["))
        idim(bind);

    /// members must be named
    silver_tokens(mod);
    string name = tok(next_alpha);
    verify(name, "expected identifier for member");
    member->name     = hold(name);

    if (tok(next_is, "["))
        idim(create_fn);
    else if (alloc)
        idim(allocate, mod, true); /// would be nice to get member context from state.. or hey, just set 1 variable and retrieve one variable.  put it in silver intern.

    tok(pop_state, true);
    map top = call(mod->e, top);
    set(top, name, member);
    return member;
}

void dim_init(member member) {
    if (member->def && !member->mod)
        member->mod = member->def->mod;
    if (!member->context)
        member->context = member->mod->defs;
    if (!member->visibility) member->visibility = Visibility_public;
    dim_set_def(member, member->def);
}

define_enum(Visibility)
define_enum(model)
define_class(silver)

int main(int argc, char **argv) {
    A_start();
    AF         pool = allocate(AF);
    cstr        src = getenv("SRC");
    cstr     import = getenv("SILVER_IMPORT");
    map    defaults = map_of(
        "module",  str(""),
        "install", import ? form(path, "%s", import) : 
                            form(path, "%s/silver-import", src ? src : "."),
        null);
    string ikey     = str("install");
    map    args     = A_args(argc, argv, defaults, ikey); print("args = %o", args);
    path   install  = get(args, ikey);
    string mkey     = str("module");
    string name     = get(args, mkey);
    path   n        = new(path, chars, name->chars);
    path   source   = call(n, absolute);

    verify (exists(source), "source %o does not exist", n);
    silver mod = new(silver, source, source, install, install);
    write(mod);

    drop(pool);
}