# todo: should be checked out and installed without import, since A is our runtime
import A [
    source:     'https://github.com/ar-visions/A',
    links:      ['A']
]

# this makes it available
public import WGPU [
    source:     'https://github.com/ar-visions/dawn@2e9297c45f48df8be17b4f3d2595063504dac16c',
    build:      ['-DDAWN_ENABLE_INSTALL=1', '-DBUILD_SHARED_LIBS=0'],
    includes:   ['dawn/webgpu', 'dawn/dawn_proc_table'],
    links:      ['webgpu_dawn']
]

import <stdlib, stdint, stdio>

meta [K,V]
class map [
    void print[] [
        return
    ]
]

class delegate [
    void method1[ int arg ] [
        return
    ]
]

meta [I]
class test [
    # I member
    void something[] [
        bool res: I is i32
        I dynamic: I[]
        I.method1 [ 2 ]
    ]
]

# [ ] work on auto release
#       import classes from A, for array, and map!
# [x] work on auto constructors and methods
# [ ] get lambda working

class app [
    i32 amember:  1
    i32 amember2: 2

    void set_members[i32 amember, i32 amember2] auto

    void a_method[i32 a_member :: i64 a_context] [

        array::int int_array

        array::map::int::string array_of_maps
        
        # meta types need to be allowed in args, emitted as 'object'
        
        int_array.push[1]

        return
    ]

    # WGPUAdapter in C99 is a struct WGPUAdapterImpl* type (opaque-reference)
    static none onAdapterRequestEnded[
            WGPURequestAdapterStatus status, WGPUAdapter adapter,
            symbol message, handle userdata] [

        ref handle u: ref userdata
        handle something: userdata

        u: something
        
        # we need to handle no token name for test[], so just []
        test::delegate t1: test[] 
        t1.something[]

        return
    ]

    none call_lambda[] [
        #lambda_desc[ 2, 2 ]
        return
    ]

    num run [] [
        fn res: sub a_method [ 2 ]
        return 0
    ]
]