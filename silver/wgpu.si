# todo: should be checked out and installed without import, since A is our runtime
import A [
    source:     'https://github.com/ar-visions/A',
    links:      ['A']
]

# this makes it available
public import WGPU [
    source:     'https://github.com/ar-visions/dawn@2e9297c45f48df8be17b4f3d2595063504dac16c',
    build:      ['-DDAWN_ENABLE_INSTALL=1', '-DBUILD_SHARED_LIBS=0'],
    includes:   ['dawn/webgpu', 'dawn/dawn_proc_table'],
    links:      ['webgpu_dawn']
]

import <stdlib, stdint, stdio>

# there is 'string {formatting}' and '%s' % [formatting]
# those are string type; const-string is "this";
# const-string's must be instanced with a string-table entry
# there is also the header service [which we dont want really]
# there is the structs in silver and C99 interops to confirm
# no typedef keyword please,
# struct Identifier is fine, for identifying structs that have typedefs
# const logic needs to be confirmed
# ref needs to be in parse_primary, as well.
##
class a [
    int value
    # ---------------------------------------------------------------
    a[ int value ] [
        value:value
    ]
    # ---------------------------------------------------------------
    cast b [
        return b[ value ]
    ]
    # ---------------------------------------------------------------
    int method[int arg] [
        return value + arg * 2
    ]
]

class b [
    int value
    # ---------------------------------------------------------------
    b[ int value ] [ value:value ]
    # ---------------------------------------------------------------
    cast a [
        return a[ value ]
    ]
    # ---------------------------------------------------------------
    int method[int arg] [
        return value + arg
    ]
]
##

# we must put named args in parsing, too. (intern cannot be set this way)
#intern struct a_struct [
#    int member
#]

class app [

    #intern int index[ short i ] [
        #printf['index [short] function called\n']
        #return cast int[ i ] + 1
    #]

    #intern int index[ int i ] [
        #printf['index [int] function called\n']
        #return i - 1
    #]

    #none test_the_index[] [
        #int result: self[22]
    #]

    # WGPUAdapter in C99 is a struct WGPUAdapterImpl* type (opaque-reference)
    static none onAdapterRequestEnded[
            WGPURequestAdapterStatus status, WGPUAdapter adapter,
            symbol message, handle userdata] [
        # this sets data at a reference position without declaring a variable
        # [[ ref WGPUAdapter ]userdata] [ 0 ]: adapter

        #ref WGPUAdapter[ userdata ][ 2 ]: adapter
        # C99: ((WGPUAdapter*)userdata)[2] = adapter

        ref handle u: ref userdata
        # C99: handle* u = (handle*)&userdata;

        handle something: userdata
        # C99: handle something = userdata

        u: something
        # C99: *u = something

        #ref WGPUAdapter udata1: ref u[2] # short-hand for ref to the indexing function

        #ref WGPUAdapter udata2: ref WGPUAdapter [ userdata ]
        # C99: WGPUAdapter* udata2 = (WGPUAdapter*)userdata
        
        # lets set it to null, and back
        #ref udata2: null
        # C99: udata = null

        #ref udata2: userdata
        # C99: udata = userdata

        # this is going to be udata2[0] = WGPUAdapter[] [default opaque type is null pointer]
        #udata2 : WGPUAdapter[]
        # C99: *udata2 = (WGPUAdapter)null

        # same
        #udata2[0]: WGPUAdapter[]
        # C99: udata2[0] = (WGPUAdapter)null

        # this is the syntax for changing our ref to a new pointer value
        #ref udata2 : [ref WGPUAdapter]userdata  

        # declares constant with =
        #ref WGPUAdapter udata4 = userdata

        # NOT ALLOWED with constants
        #ref udata4 : [ref WGPUAdapter]userdata

        # NOT ALLOWED with constants
        #ref udata4 = [ref WGPUAdapter]userdata  

        # can a ref be null?  why not, if you want to make that an option.  that happens, ALOT.
        # C99: if (!value) {
        #if [ not ref value ] [ # ref value[0] is allowed to give us a pointer to it, so we cannot have if ref value [ returns-int ]
        #    # this is a null reference
        #    printf('...')
        #]

        # C99: if (value) {
        #if [ ref value ][ # this gets the pointer, ref value in C is just value
        #    printf('...')
        #]

        # C99: if (&value[0]) {
        #if [ ref value[0] ][ # this is the pointer of the first element
        #    printf('...')
        #]

        # C99: if (value[0]) {
        #if [ value[0] ] # this is the actual value of the first element in memory
        #[
        #    printf('...')
        #]

        # C99: if (*value) {
        #if [ value ][   # so is this
        #    printf('...')
        #]
        return
    ]

    # this needs to be converted to more than a pointer, but something to hold onto sub address and data
    #int lambda_desc[ int, short ]

    #void set_lambda[ int fn[ int, short ] ] [
       #lambda_desc = fn
    #]

    none call_lambda[] [
        #lambda_desc[ 2, 2 ]
        return
    ]

    # we want lambdas flat on the method, to prevent pyramid syntax; 
    # even 2 levels of lambda is fairly unacceptable so why allow it?

    #int my_callback [ int arg1, short arg2 :: int some_context, int more ] [
    #    printf['my_callback called: %i %i, %i %i\n', arg1, arg2, some_context, more]
    #]

    #int my_callback2 [ int arg1, short arg2 ] [
    #    printf['my_callback2 called\n']
    #]

    num run [] [
        #set_lambda  [ sub my_callback[ some_context:22, more:44 ] ]
        #call_lambda [ ]
        #set_lambda  [ sub my_callback2 ]
        #call_lambda [ ]
        return 0
    ]
]