#ifndef _TOKENS_
#define _TOKENS_
#include <A>

#define Loc_schema(X,Y) \
    i_prop    (X,Y, public, path,   source) \
    i_prop    (X,Y, public, num,    line) \
    i_prop    (X,Y, public, num,    column) \
    i_override(X,Y, method, init)
declare_class(Loc)


typedef struct ENode*                   ENode;
typedef struct EIdent*                  EIdent;
typedef struct EModule*                 EModule;
typedef struct EMember*                 EMember;
typedef struct EMetaMember*             EMetaMember;
typedef struct EMethod*                 EMethod;
typedef struct EClass*                  EClass;
typedef struct EProp*                   EProp;
typedef struct EStruct*                 EStruct;
typedef struct EOperator*               EOperator;
typedef struct ECompareEquals*          ECompareEquals;
typedef struct ECompareNotEquals*       ECompareNotEquals;
typedef struct EAdd*                    EAdd;
typedef struct ESub*                    ESub;
typedef struct EMul*                    EMul;
typedef struct EDiv*                    EDiv;
typedef struct EOr*                     EOr;
typedef struct EAnd*                    EAnd;
typedef struct EXor*                    EXor;
typedef struct EIs*                     EIs;
typedef struct EInherits*               EInherits;
typedef struct EImport*                 EImport;
typedef struct EStatements*             EStatements;
typedef struct EModel*                  EModel;
typedef struct EDeclaration*            EDeclaration;
typedef struct EConstruct*              EConstruct;
typedef struct EExplicitCast*           EExplicitCast;
typedef struct EPrimitive*              EPrimitive;
typedef struct EUndefined*              EUndefined;
typedef struct EParenthesis*            EParenthesis;
typedef struct ELogicalNot*             ELogicalNot;
typedef struct EBitwiseNot*             EBitwiseNot;
typedef struct ERef*                    ERef;
typedef struct ERefCast*                ERefCast;
typedef struct EIndex*                  EIndex;
typedef struct EAssign*                 EAssign;
typedef struct EAssignAdd*              EAssignAdd;
typedef struct EAssignSub*              EAssignSub;
typedef struct EAssignMul*              EAssignMul;
typedef struct EAssignDiv*              EAssignDiv;
typedef struct EAssignOr*               EAssignOr;
typedef struct EAssignAnd*              EAssignAnd;
typedef struct EAssignXor*              EAssignXor;
typedef struct EAssignShiftR*           EAssignShiftR;
typedef struct EAssignShiftL*           EAssignShiftL;
typedef struct EAssignMod*              EAssignMod;
typedef struct EIf*                     EIf;
typedef struct EFor*                    EFor;
typedef struct EWhile*                  EWhile;
typedef struct EDoWhile*                EDoWhile;
typedef struct EBreak*                  EBreak;
typedef struct ELiteralReal*            ELiteralReal;
typedef struct ELiteralInt*             ELiteralInt;
typedef struct ELiteralStr*             ELiteralStr;
typedef struct ELiteralStrInterp*       ELiteralStrInterp;
typedef struct ELiteralBool*            ELiteralBool;
typedef struct ESubProc*                ESubProc;
typedef struct ERuntimeType*            ERuntimeType;
typedef struct EMethodCall*             EMethodCall;
typedef struct EMethodReturn*           EMethodReturn;
typedef struct Token*                   Token;


#define EContext_schema(X,Y) \
    i_prop  (   X,Y,  public, EModule,   module) \
    i_prop  (   X,Y,  public, EMember,   method) \
    i_prop  (   X,Y,  public, array,     states) \
    i_prop  (   X,Y,  public, bool,    raw_primitives) \
    i_prop  (   X,Y,  public, map,       values) \
    i_prop  (   X,Y,  public, num,       indent_level) \
    i_method(   X,Y,  public, string,    indent) \
    i_method(   X,Y,  public, none,      set_value, A, A) \
    i_method(   X,Y,  public, A,         get_value, A) \
    i_method(   X,Y,  public, none,      push, string) \
    i_method(   X,Y,  public, none,      pop) \
    i_method(   X,Y,  public, string,    top_state)
declare_class(EContext)


#define ENode_schema(X,Y) \
    i_prop  (   X,Y,  public, string,    name) \
    i_prop  (   X,Y,  public, AType,     type) \
    i_prop  (   X,Y,  intern, num,       id) \
    i_method(   X,Y,  bool,      equals, X) \
    i_method(   X,Y,  string,    emit, A) \
    i_override(X,Y,   cast,      bool) \
    i_override(X,Y,   method,    init)
declare_class(ENode)

#define EUndefined_schema(X,Y)
declare_mod(EUndefined, ENode)

#define ELiteralInt_schema(X,Y) \
    i_prop(X,Y, public, num, value)
declare_mod(ELiteralInt, ENode);

#define ELiteralReal_schema(X,Y) \
    i_prop(X,Y, public, real, value)
declare_mod(ELiteralReal, ENode);

#define ELiteralStr_schema(X,Y) \
    i_prop(X,Y, public, string, value)
declare_mod(ELiteralStr, ENode);

#define ELiteralBool_schema(X,Y) \
    i_prop(X,Y, public, bool, value)
declare_mod(ELiteralBool, ENode);


#define Visibility_schema(X,Y) \
    enum_value(X,Y, undefined) \
    enum_value(X,Y, intern) \
    enum_value(X,Y, public)
declare_enum(Visibility)

#define Token_schema(X,Y) \
    i_prop  (X,Y, public, cstr,   chars) \
    i_prop  (X,Y, public, i32,    chr) \
    i_prop  (X,Y, intern, sz,     len) \
    i_prop  (X,Y, intern, path,   file) \
    i_prop  (X,Y, intern, num,    line) \
    i_prop  (X,Y, intern, num,    column) \
    i_prop  (X,Y, intern, Loc,    loc) \
    i_method(X,Y, public, bool,   eq, cstr) \
    i_method(X,Y, public, num,    cmp, cstr) \
    i_method(X,Y, public, AType,  is_string) \
    i_method(X,Y, public, A,      convert_literal) \
    i_override(X,Y, method, init) \
    i_override(X,Y, method, compare) \
    i_override(X,Y, cast,   bool)
declare_class(Token)

#define Tokens_schema(X,Y)\
    i_prop  (X,Y, public, cpath,   file) \
    i_prop  (X,Y, public, carray,  tokens) \
    i_prop  (X,Y, public, cnum,    cursor) \
    i_prop  (X,Y, intern, array,  stack) \
    i_method(X,Y, public, none,   push_state,   array, num) \
    i_method(X,Y, public, none,   push_current) \
    i_method(X,Y, public, none,   pop) \
    i_method(X,Y, public, Token,  read, num) \
    i_method(X,Y, public, Token,  next) \
    i_method(X,Y, public, Token,  consume) \
    i_method(X,Y, public, Token,  peek) \
    i_method(X,Y, public, bool,   next_is, symbol) \
    i_method(X,Y, public, none,   transfer, Tokens) \
    i_override(X,Y, method, init) \
    i_override(X,Y, cast,   bool)
declare_class(Tokens)

array parse_tokens(object input);
bool  next_is(Tokens tokens, symbol cs);
bool  is_alpha(A any);

#endif