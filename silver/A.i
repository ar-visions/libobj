# 0 "../silver/A.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "../silver/A.c"
# 1 "../silver/A.h" 1



# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 392 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4
# 486 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 559 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 560 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 561 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 487 "/usr/include/features.h" 2 3 4
# 510 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 511 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4
# 52 "/usr/include/stdio.h" 3 4
typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;
# 77 "/usr/include/stdio.h" 3 4
typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4
# 143 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 178 "/usr/include/stdio.h" 3 4
extern int fclose (FILE *__stream);
# 188 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 205 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char[20]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char __s[20]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 222 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (__builtin_free, 1)));






extern int fflush (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 258 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 293 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 308 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 328 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 403 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));





# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 119 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 431 "/usr/include/stdio.h" 2 3 4



extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 459 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 538 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 549 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 565 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
# 632 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 702 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 736 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 760 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 786 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 823 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream);





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (pclose, 1))) ;






extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1)));
# 867 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 885 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 902 "/usr/include/stdio.h" 3 4

# 5 "../silver/A.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
typedef int wchar_t;
# 33 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 386 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;
# 59 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 144 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 102 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 227 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 396 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));


extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)))
    __attribute__ ((__malloc__ (__builtin_free, 1)));


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__ (reallocarray, 1)));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 575 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
     __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 654 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 682 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 738 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 791 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;
# 808 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 828 "/usr/include/stdlib.h" 3 4
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 848 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 880 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1, 3)))
  __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 967 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 1013 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1023 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1024 "/usr/include/stdlib.h" 2 3 4
# 1035 "/usr/include/stdlib.h" 3 4

# 6 "../silver/A.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 107 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 173 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 246 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 293 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 323 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 350 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 407 "/usr/include/string.h" 3 4
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 432 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)))
    __attribute__ ((__access__ (__write_only__, 2, 3)));
# 458 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));
# 489 "/usr/include/string.h" 3 4
extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 539 "/usr/include/string.h" 3 4

# 7 "../silver/A.h" 2
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4



extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



# 8 "../silver/A.h" 2
# 1 "/usr/include/x86_64-linux-gnu/ffi.h" 1 3 4
# 59 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/ffitarget.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/ffitarget.h" 3 4
typedef unsigned long ffi_arg;
typedef signed long ffi_sarg;



typedef enum ffi_abi {
# 93 "/usr/include/x86_64-linux-gnu/ffitarget.h" 3 4
  FFI_FIRST_ABI = 1,
  FFI_UNIX64,
  FFI_WIN64,
  FFI_EFI64 = FFI_WIN64,
  FFI_GNUW64,
  FFI_LAST_ABI,
  FFI_DEFAULT_ABI = FFI_UNIX64
# 124 "/usr/include/x86_64-linux-gnu/ffitarget.h" 3 4
} ffi_abi;
# 151 "/usr/include/x86_64-linux-gnu/ffitarget.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/cet.h" 1 3 4
# 152 "/usr/include/x86_64-linux-gnu/ffitarget.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/ffi.h" 2 3 4







# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
} max_align_t;
# 68 "/usr/include/x86_64-linux-gnu/ffi.h" 2 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 1 3 4
# 203 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 195 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 81 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 2 3 4
# 82 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 196 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 200 "/usr/include/limits.h" 2 3 4
# 204 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/11/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 2 3 4
# 69 "/usr/include/x86_64-linux-gnu/ffi.h" 2 3 4
# 104 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
typedef struct _ffi_type
{
  size_t size;
  unsigned short alignment;
  unsigned short type;
  struct _ffi_type **elements;
} ffi_type;
# 188 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
extern ffi_type ffi_type_void;
extern ffi_type ffi_type_uint8;
extern ffi_type ffi_type_sint8;
extern ffi_type ffi_type_uint16;
extern ffi_type ffi_type_sint16;
extern ffi_type ffi_type_uint32;
extern ffi_type ffi_type_sint32;
extern ffi_type ffi_type_uint64;
extern ffi_type ffi_type_sint64;
extern ffi_type ffi_type_float;
extern ffi_type ffi_type_double;
extern ffi_type ffi_type_pointer;


extern ffi_type ffi_type_longdouble;





extern ffi_type ffi_type_complex_float;
extern ffi_type ffi_type_complex_double;

extern ffi_type ffi_type_complex_longdouble;






typedef enum {
  FFI_OK = 0,
  FFI_BAD_TYPEDEF,
  FFI_BAD_ABI,
  FFI_BAD_ARGTYPE
} ffi_status;

typedef struct {
  ffi_abi abi;
  unsigned nargs;
  ffi_type **arg_types;
  ffi_type *rtype;
  unsigned bytes;
  unsigned flags;



} ffi_cif;
# 251 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
typedef union {
  ffi_sarg sint;
  ffi_arg uint;
  float flt;
  char data[8];
  void* ptr;
} ffi_raw;
# 270 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
typedef ffi_raw ffi_java_raw;




void ffi_raw_call (ffi_cif *cif,
     void (*fn)(void),
     void *rvalue,
     ffi_raw *avalue);

 void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);
 void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);
 size_t ffi_raw_size (ffi_cif *cif);







void ffi_java_raw_call (ffi_cif *cif,
   void (*fn)(void),
   void *rvalue,
   ffi_java_raw *avalue) __attribute__((deprecated));



void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw) __attribute__((deprecated));

void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args) __attribute__((deprecated));

size_t ffi_java_raw_size (ffi_cif *cif) __attribute__((deprecated));
# 310 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
typedef struct {




  union {
    char tramp[32];
    void *ftramp;
  };

  ffi_cif *cif;
  void (*fun)(ffi_cif*,void*,void**,void*);
  void *user_data;
} ffi_closure

    __attribute__((aligned (8)))

    ;







 void *ffi_closure_alloc (size_t size, void **code);
 void ffi_closure_free (void *);
# 346 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
 ffi_status
ffi_prep_closure (ffi_closure*,
    ffi_cif *,
    void (*fun)(ffi_cif*,void*,void**,void*),
    void *user_data)

  __attribute__((deprecated ("use ffi_prep_closure_loc instead")))



  ;

 ffi_status
ffi_prep_closure_loc (ffi_closure*,
        ffi_cif *,
        void (*fun)(ffi_cif*,void*,void**,void*),
        void *user_data,
        void*codeloc);




typedef struct {




  char tramp[32];

  ffi_cif *cif;







  void (*translate_args)(ffi_cif*,void*,void**,void*);
  void *this_closure;



  void (*fun)(ffi_cif*,void*,ffi_raw*,void*);
  void *user_data;

} ffi_raw_closure;

typedef struct {




  char tramp[32];


  ffi_cif *cif;







  void (*translate_args)(ffi_cif*,void*,void**,void*);
  void *this_closure;



  void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*);
  void *user_data;

} ffi_java_raw_closure;

 ffi_status
ffi_prep_raw_closure (ffi_raw_closure*,
        ffi_cif *cif,
        void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
        void *user_data);

 ffi_status
ffi_prep_raw_closure_loc (ffi_raw_closure*,
     ffi_cif *cif,
     void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
     void *user_data,
     void *codeloc);


 ffi_status
ffi_prep_java_raw_closure (ffi_java_raw_closure*,
             ffi_cif *cif,
             void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
             void *user_data) __attribute__((deprecated));

 ffi_status
ffi_prep_java_raw_closure_loc (ffi_java_raw_closure*,
          ffi_cif *cif,
          void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
          void *user_data,
          void *codeloc) __attribute__((deprecated));






typedef struct {
  void *tramp;
  ffi_cif *cif;
  void (*fun)(ffi_cif*,void*,void**,void*);
} ffi_go_closure;

 ffi_status ffi_prep_go_closure (ffi_go_closure*, ffi_cif *,
    void (*fun)(ffi_cif*,void*,void**,void*));

 void ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
    void **avalue, void *closure);






ffi_status ffi_prep_cif(ffi_cif *cif,
   ffi_abi abi,
   unsigned int nargs,
   ffi_type *rtype,
   ffi_type **atypes);


ffi_status ffi_prep_cif_var(ffi_cif *cif,
       ffi_abi abi,
       unsigned int nfixedargs,
       unsigned int ntotalargs,
       ffi_type *rtype,
       ffi_type **atypes);


void ffi_call(ffi_cif *cif,
       void (*fn)(void),
       void *rvalue,
       void **avalue);


ffi_status ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type,
       size_t *offsets);
# 9 "../silver/A.h" 2






# 14 "../silver/A.h"
typedef void none;
typedef signed char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef unsigned long long num;
typedef unsigned int bool;
typedef float f32;
typedef double f64;
typedef long double f128;
typedef double real;

typedef struct A_f* AType;

enum A_TYPE {
    A_TYPE_NONE = 0,
    A_TYPE_PROP = 1,
    A_TYPE_IMETHOD = 2,
    A_TYPE_SMETHOD = 4,
    A_TYPE_CONSTRUCT = 8,
    A_TYPE_ENUMV = 16
};
# 167 "../silver/A.h"
typedef bool(*global_init_fn)();






typedef struct A_f* A_t;

typedef struct args_t {
    num count;
    A_t arg_0, arg_1, arg_2, arg_3,
                    arg_4, arg_5, arg_6, arg_7;
} args_t;

typedef struct method_t {
    void* address;
    void* ffi_cif;
    void* ffi_args;
} method_t;

typedef struct prop_t {
    void* address;
} prop_t;



typedef struct member_t {
    char* name;
    A_t type;
    num offset;
    enum A_TYPE member_type;
    args_t args;
    union {
        method_t* method;
        prop_t* prop;
    };
} member_t;
# 324 "../silver/A.h"
void A_lazy_init(global_init_fn fn);
# 376 "../silver/A.h"

# 376 "../silver/A.h"
#pragma pack(push, 1)
# 376 "../silver/A.h"
 typedef struct A { A_t type; num refs; struct A* data; num alloc; num count; struct A* origin; } *A;
# 376 "../silver/A.h"
#pragma pack(pop)
# 376 "../silver/A.h"
 typedef struct A_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } A_f; typedef struct A_ctr { A (*A_default)(struct A_f*); } A_ctr; extern A_f A_type;




typedef struct i8_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } i8_f, *i8_t; extern i8_f i8_type;
typedef struct i16_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } i16_f, *i16_t; extern i16_f i16_type;
typedef struct i32_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } i32_f, *i32_t; extern i32_f i32_type;
typedef struct i64_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } i64_f, *i64_t; extern i64_f i64_type;
typedef struct u8_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } u8_f, *u8_t; extern u8_f u8_type;
typedef struct u16_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } u16_f, *u16_t; extern u16_f u16_type;
typedef struct u32_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } u32_f, *u32_t; extern u32_f u32_type;
typedef struct u64_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } u64_f, *u64_t; extern u64_f u64_type;
typedef struct f32_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } f32_f, *f32_t; extern f32_f f32_type;
typedef struct f64_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } f64_f, *f64_t; extern f64_f f64_type;
typedef struct f128_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } f128_f, *f128_t; extern f128_f f128_type;
typedef struct cstr_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } cstr_f, *cstr_t; extern cstr_f cstr_type;
typedef struct bool_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } bool_f, *bool_t; extern bool_f bool_type;
typedef struct none_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } none_f, *none_t; extern none_f none_type;
typedef struct num_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } num_f, *num_t; extern num_f num_type;


typedef struct AType_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } AType_f, *AType_t; extern AType_f AType_type;







# 405 "../silver/A.h"
#pragma pack(push, 1)
# 405 "../silver/A.h"
 typedef struct item { struct item* next; struct item* prev; A element; } *item;
# 405 "../silver/A.h"
#pragma pack(pop)
# 405 "../silver/A.h"
 typedef struct item_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(item); none (*destructor)(item); i32 (*compare)(item,item); u64 (*hash)(item); bool (*boolean)(item); } item_f, *item_t; typedef struct item_ctr { item (*item_default)(struct item_f*); } item_ctr; extern item_ctr item_new; extern item_f item_type;








# 413 "../silver/A.h"
#pragma pack(push, 1)
# 413 "../silver/A.h"
 typedef struct collection { } *collection;
# 413 "../silver/A.h"
#pragma pack(pop)
# 413 "../silver/A.h"
 typedef struct collection_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(collection); none (*destructor)(collection); i32 (*compare)(collection,collection); u64 (*hash)(collection); bool (*boolean)(collection); } collection_f, *collection_t; extern collection_f collection_type;
# 426 "../silver/A.h"

# 426 "../silver/A.h"
#pragma pack(push, 1)
# 426 "../silver/A.h"
 typedef struct list { item first; item last; i64 count; i32 public_integer; } *list;
# 426 "../silver/A.h"
#pragma pack(pop)
# 426 "../silver/A.h"
 typedef struct list_f { struct collection_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(list); none (*destructor)(list); i32 (*compare)(list,list); u64 (*hash)(list); bool (*boolean)(list); A (*pop)(list); none (*push)(list, A); A (*get)(list, i32); num (*count)(list); } list_f, *list_t; typedef struct list_ctr { } list_ctr; extern list_ctr list_new; extern list_f list_type;

typedef char* cstr;
# 444 "../silver/A.h"

# 444 "../silver/A.h"
#pragma pack(push, 1)
# 444 "../silver/A.h"
 typedef struct array { A* elements; i32 alloc; i32 len; } *array;
# 444 "../silver/A.h"
#pragma pack(pop)
# 444 "../silver/A.h"
 typedef struct array_f { struct collection_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(array); none (*destructor)(array); i32 (*compare)(array,array); u64 (*hash)(array); bool (*boolean)(array); array (*pop)(array); none (*push)(array,A); A (*get)(array, i32); array (*count)(array); num (*index_of)(array, A); none (*push_symbols)(array, cstr, ...); none (*push_objects)(array, A, ...); } array_f, *array_t; typedef struct array_ctr { } array_ctr; extern array_ctr array_new; extern array_f array_type;
# 457 "../silver/A.h"

# 457 "../silver/A.h"
#pragma pack(push, 1)
# 457 "../silver/A.h"
 typedef struct string { char* chars; num alloc; num len; u64 h; } *string;
# 457 "../silver/A.h"
#pragma pack(pop)
# 457 "../silver/A.h"
 typedef struct string_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(string); none (*destructor)(string); i32 (*compare)(string,string); u64 (*hash)(string); bool (*boolean)(string); array (*split)(string, A); num (*index_of)(string, cstr); } string_f, *string_t; typedef struct string_ctr { string (*string_default)(struct string_f*); string (*string_of_reserve)(struct string_f*, num); string (*string_of_cstr)(struct string_f*, cstr, num); string (*string_of_file)(struct string_f*, cstr); } string_ctr; extern string_ctr string_new; extern string_f string_type;
# 469 "../silver/A.h"

# 469 "../silver/A.h"
#pragma pack(push, 1)
# 469 "../silver/A.h"
 typedef struct vector { } *vector;
# 469 "../silver/A.h"
#pragma pack(pop)
# 469 "../silver/A.h"
 typedef struct vector_f { struct collection_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(vector); none (*destructor)(vector); i32 (*compare)(vector,vector); u64 (*hash)(vector); bool (*boolean)(vector); A (*pop)(vector); none (*push)(vector, A); A (*get)(vector, i32); num (*count)(vector); } vector_f, *vector_t; typedef struct vector_ctr { } vector_ctr; extern vector_ctr vector_new; extern vector_f vector_type;

A A_hold(A a);
void A_drop(A a);
A hold(A a);
void drop(A a);


A A_alloc(A_t type, num count);

A object(A instance);
A data(A instance);
# 536 "../silver/A.h"
typedef void* handle;

void A_push_type(A_t type);

A_f** A_types(num* length);
member_t* A_member(A_t type, enum A_TYPE member_type, char* name);
A A_method(A_t type, char* method_name, array args);
A A_primitive(A_t type, void* data);
A A_enum(A_t enum_type, i32 value);
A A_primitive_i8(i8);
A A_primitive_u8(u8);
A A_primitive_i16(i16);
A A_primitive_u16(u16);
A A_primitive_i32(i32);
A A_primitive_u32(u32);
A A_primitive_i64(i64);
A A_primitive_u64(u64);
A A_primitive_f32(f32);
A A_primitive_f64(f64);
A A_primitive_cstr(cstr);
A A_primitive_none();
A A_primitive_bool(bool);

A A_realloc(A, num);
void A_push(A, A);

void A_finish_types();
# 2 "../silver/A.c" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));
# 142 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 327 "/usr/include/ctype.h" 3 4

# 3 "../silver/A.c" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h" 1 3 4
# 4 "../silver/A.c" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 255 "/usr/include/unistd.h" 3 4
typedef __useconds_t useconds_t;
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 309 "/usr/include/unistd.h" 3 4
extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 339 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 358 "/usr/include/unistd.h" 3 4
extern int close (int __fd);




extern void closefrom (int __lowfd) __attribute__ ((__nothrow__ , __leaf__));







extern ssize_t read (int __fd, void *__buf, size_t __nbytes)
    __attribute__ ((__access__ (__write_only__, 2, 3)));





extern ssize_t write (int __fd, const void *__buf, size_t __n)
    __attribute__ ((__access__ (__read_only__, 2, 3)));
# 389 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset)
    __attribute__ ((__access__ (__write_only__, 2, 3)));






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset)
    __attribute__ ((__access__ (__read_only__, 2, 3)));
# 437 "/usr/include/unistd.h" 3 4
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 452 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 464 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 489 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 531 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;
# 545 "/usr/include/unistd.h" 3 4
extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__))
    __attribute__ ((__access__ (__write_only__, 1)));




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));
# 564 "/usr/include/unistd.h" 3 4
extern char **__environ;







extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 619 "/usr/include/unistd.h" 3 4
extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT,


    _SC_MINSIGSTKSZ,


    _SC_SIGSTKSZ

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 631 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 2, 3)));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 682 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 2, 1)));
# 722 "/usr/include/unistd.h" 3 4
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;
# 778 "/usr/include/unistd.h" 3 4
extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));
# 799 "/usr/include/unistd.h" 3 4
extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)))
     __attribute__ ((__access__ (__write_only__, 2, 3)));



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)))
     __attribute__ ((__access__ (__write_only__, 2, 3)));





extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)))
     __attribute__ ((__access__ (__write_only__, 3, 4)));



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4








extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4


# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4

# 904 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__read_only__, 1, 2)));



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
     __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__read_only__, 1, 2)));




extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);
# 1002 "/usr/include/unistd.h" 3 4
extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 1026 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1049 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1070 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1091 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1114 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1150 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);
# 1159 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 1198 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 1218 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 1219 "/usr/include/unistd.h" 2 3 4


# 5 "../silver/A.c" 2


# 6 "../silver/A.c"
static global_init_fn* call_after;
static num call_after_alloc;
static num call_after_count;
static array keywords;

void A_lazy_init(global_init_fn fn) {
    if (call_after_count == call_after_alloc) {
        global_init_fn prev = call_after;
        num alloc_prev = call_after_alloc;
        call_after = calloc(32 + (call_after_alloc << 1), sizeof(global_init_fn));
        if (prev) {
            memcpy(call_after, prev, sizeof(global_init_fn) * alloc_prev);
            free(prev);
        }
    }
    call_after[call_after_count++] = fn;
}

A_f** types;
num types_alloc;
num types_len;

void A_push_type(A_f* type) {
    if (types_alloc == types_len) {
        A_f** prev = types;
        num alloc_prev = types_alloc;
        types = calloc(32 + (types_alloc << 1), sizeof(A_f*));
        if (prev) {
            memcpy(types, prev, sizeof(A_f*) * alloc_prev);
            free(prev);
        }
    }
    types[types_len++] = type;
}

A_f** A_types(num* length) {
    *length = types_len;
    return types;
}




A A_alloc(A_f* type, num count) {
    A a = calloc(1, (type == ((struct A_f*)&A_type) ? 0 : sizeof(struct A)) + type->size * count);
    a->type = type;
    a->origin = a;
    a->data = &a[1];
    a->count = count;
    a->alloc = count;
    A_f* a_type = &A_type;
    A_f* current = type;
    while (current) {
        if (current->init)
            current->init(a->data);
        if (current == a_type)
            break;
        current = current->parent;
    }
    return a->data;
}


A A_realloc(A a, num alloc) {
    A obj = object(a);
    
# 71 "../silver/A.c" 3 4
   ((void) sizeof ((
# 71 "../silver/A.c"
   obj->type->traits == (1 << 0)
# 71 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 71 "../silver/A.c"
   obj->type->traits == (1 << 0)
# 71 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 71 "../silver/A.c"
   "obj->type->traits == A_TRAIT_PRIMITIVE"
# 71 "../silver/A.c" 3 4
   , "../silver/A.c", 71, __extension__ __PRETTY_FUNCTION__); }))
# 71 "../silver/A.c"
                                                 ;
    A re = calloc(1, sizeof(struct A) + obj->type->size * alloc);
    num count = obj->count < alloc ? obj->count : alloc;
    memcpy(&re[1], obj->data, obj->type->size * count);
    if (obj->data != &obj[1])
        free(&obj->data[-1]);
    re->origin = obj;
    obj->data = &re[1];
    obj->count = count;
    obj->alloc = alloc;
    return obj->data;
}

void A_push(A a, A value) {
    A obj = object(a);
    
# 86 "../silver/A.c" 3 4
   ((void) sizeof ((
# 86 "../silver/A.c"
   obj->type->traits == (1 << 0)
# 86 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 86 "../silver/A.c"
   obj->type->traits == (1 << 0)
# 86 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 86 "../silver/A.c"
   "obj->type->traits == A_TRAIT_PRIMITIVE"
# 86 "../silver/A.c" 3 4
   , "../silver/A.c", 86, __extension__ __PRETTY_FUNCTION__); }))
# 86 "../silver/A.c"
                                                 ;
    num sz = obj->type->size;
    if (obj->count == obj->alloc)
        A_realloc(a, 32 + obj->alloc << 1);
    memcpy(&((u8*)obj->data)[obj->count++ * sz], value, sz);
}

void A_finish_types() {
    num types_len;
    A_f** types = A_types(&types_len);
    const num max_args = 8;


    for (num i = 0; i < types_len; i++) {
        A_f* type = types[i];


        for (num m = 0; m < type->member_count; m++) {
            member_t* mem = &type->members[m];
            if (mem->member_type & (A_TYPE_IMETHOD | A_TYPE_SMETHOD | A_TYPE_CONSTRUCT)) {

                mem->method = calloc(1, sizeof(method_t));
                mem->method->ffi_cif = calloc(1, sizeof(ffi_cif));
                mem->method->ffi_args = calloc(max_args, sizeof(ffi_type*));
                ffi_type **arg_types = (ffi_type**)mem->method->ffi_args;
                for (num i = 0; i < mem->args.count; i++) {
                    A_f* a_type = ((A_f**)&mem->args.arg_0)[i];
                    bool is_prim = a_type->traits & (1 << 0);
                    arg_types[i] = is_prim ? a_type->arb : &ffi_type_pointer;
                }
                ffi_status status = ffi_prep_cif(
                    (ffi_cif*) mem->method->ffi_cif, FFI_DEFAULT_ABI, mem->args.count,
                    (ffi_type*)mem->type->arb, arg_types);
                
# 119 "../silver/A.c" 3 4
               ((void) sizeof ((
# 119 "../silver/A.c"
               status == FFI_OK
# 119 "../silver/A.c" 3 4
               ) ? 1 : 0), __extension__ ({ if (
# 119 "../silver/A.c"
               status == FFI_OK
# 119 "../silver/A.c" 3 4
               ) ; else __assert_fail (
# 119 "../silver/A.c"
               "status == FFI_OK"
# 119 "../silver/A.c" 3 4
               , "../silver/A.c", 119, __extension__ __PRETTY_FUNCTION__); }))
# 119 "../silver/A.c"
                                       ;
                u8 *rel = (mem->member_type == A_TYPE_CONSTRUCT) ?
                    (u8*)type->factory : (u8*)type;
                
# 122 "../silver/A.c" 3 4
               ((void) sizeof ((
# 122 "../silver/A.c"
               rel
# 122 "../silver/A.c" 3 4
               ) ? 1 : 0), __extension__ ({ if (
# 122 "../silver/A.c"
               rel
# 122 "../silver/A.c" 3 4
               ) ; else __assert_fail (
# 122 "../silver/A.c"
               "rel"
# 122 "../silver/A.c" 3 4
               , "../silver/A.c", 122, __extension__ __PRETTY_FUNCTION__); }))
# 122 "../silver/A.c"
                          ;
                memcpy(&mem->method->address, &((u8*)rel)[mem->offset], sizeof(void*));
                
# 124 "../silver/A.c" 3 4
               ((void) sizeof ((
# 124 "../silver/A.c"
               mem->method->address
# 124 "../silver/A.c" 3 4
               ) ? 1 : 0), __extension__ ({ if (
# 124 "../silver/A.c"
               mem->method->address
# 124 "../silver/A.c" 3 4
               ) ; else __assert_fail (
# 124 "../silver/A.c"
               "mem->method->address"
# 124 "../silver/A.c" 3 4
               , "../silver/A.c", 124, __extension__ __PRETTY_FUNCTION__); }))
# 124 "../silver/A.c"
                                           ;
            }
        }
    }
}

member_t* A_member(A_f* type, enum A_TYPE member_type, char* name) {
    for (num i = 0; i < type->member_count; i++) {
        member_t* mem = &type->members[i];
        if (mem->member_type & member_type && strcmp(mem->name, name) == 0)
            return mem;
    }
    return 0;
}

A A_primitive(A_f* type, void* data) {
    
# 140 "../silver/A.c" 3 4
   ((void) sizeof ((
# 140 "../silver/A.c"
   type->traits & (1 << 0)
# 140 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 140 "../silver/A.c"
   type->traits & (1 << 0)
# 140 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 140 "../silver/A.c"
   "type->traits & A_TRAIT_PRIMITIVE"
# 140 "../silver/A.c" 3 4
   , "../silver/A.c", 140, __extension__ __PRETTY_FUNCTION__); }))
# 140 "../silver/A.c"
                                           ;
    A copy = A_alloc(type, type->size);
    memcpy(copy, data, type->size);
    return copy;
}

A A_enum(A_f* type, i32 data) {
    
# 147 "../silver/A.c" 3 4
   ((void) sizeof ((
# 147 "../silver/A.c"
   type->traits & (1 << 1)
# 147 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 147 "../silver/A.c"
   type->traits & (1 << 1)
# 147 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 147 "../silver/A.c"
   "type->traits & A_TRAIT_ENUM"
# 147 "../silver/A.c" 3 4
   , "../silver/A.c", 147, __extension__ __PRETTY_FUNCTION__); }))
# 147 "../silver/A.c"
                                      ;
    
# 148 "../silver/A.c" 3 4
   ((void) sizeof ((
# 148 "../silver/A.c"
   type->size == sizeof(i32)
# 148 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 148 "../silver/A.c"
   type->size == sizeof(i32)
# 148 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 148 "../silver/A.c"
   "type->size == sizeof(i32)"
# 148 "../silver/A.c" 3 4
   , "../silver/A.c", 148, __extension__ __PRETTY_FUNCTION__); }))
# 148 "../silver/A.c"
                                    ;
    A copy = A_alloc(type, type->size);
    memcpy(copy, &data, type->size);
    return copy;
}

A A_primitive_i8(i8 data) { return A_primitive(&i8_type, &data); }
A A_primitive_u8(u8 data) { return A_primitive(&u8_type, &data); }
A A_primitive_i16(i16 data) { return A_primitive(&i16_type, &data); }
A A_primitive_u16(u16 data) { return A_primitive(&u16_type, &data); }
A A_primitive_i32(i32 data) { return A_primitive(&i32_type, &data); }
A A_primitive_u32(u32 data) { return A_primitive(&u32_type, &data); }
A A_primitive_i64(i64 data) { return A_primitive(&i64_type, &data); }
A A_primitive_u64(u64 data) { return A_primitive(&u64_type, &data); }
A A_primitive_f32(f32 data) { return A_primitive(&f32_type, &data); }
A A_primitive_f64(f64 data) { return A_primitive(&f64_type, &data); }
A A_primitive_cstr(cstr data) { return A_primitive(&cstr_type, &data); }
A A_primitive_none() { return A_primitive(&none_type, &data); }
A A_primitive_bool(bool data) { return A_primitive(&bool_type, &data); }


A A_method(A_f* type, char* method_name, array args) {
    member_t* mem = A_member(type, A_TYPE_IMETHOD | A_TYPE_SMETHOD, method_name);
    
# 171 "../silver/A.c" 3 4
   ((void) sizeof ((
# 171 "../silver/A.c"
   mem
# 171 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 171 "../silver/A.c"
   mem
# 171 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 171 "../silver/A.c"
   "mem"
# 171 "../silver/A.c" 3 4
   , "../silver/A.c", 171, __extension__ __PRETTY_FUNCTION__); }))
# 171 "../silver/A.c"
              ;
    const num max_args = 8;
    void* arg_values[max_args];

    
# 175 "../silver/A.c" 3 4
   ((void) sizeof ((
# 175 "../silver/A.c"
   args->len <= max_args
# 175 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 175 "../silver/A.c"
   args->len <= max_args
# 175 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 175 "../silver/A.c"
   "args->len <= max_args"
# 175 "../silver/A.c" 3 4
   , "../silver/A.c", 175, __extension__ __PRETTY_FUNCTION__); }))
# 175 "../silver/A.c"
                                ;
    
# 176 "../silver/A.c" 3 4
   ((void) sizeof ((
# 176 "../silver/A.c"
   args->len == mem->args.count
# 176 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 176 "../silver/A.c"
   args->len == mem->args.count
# 176 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 176 "../silver/A.c"
   "args->len == mem->args.count"
# 176 "../silver/A.c" 3 4
   , "../silver/A.c", 176, __extension__ __PRETTY_FUNCTION__); }))
# 176 "../silver/A.c"
                                       ;
    for (num i = 0; i < args->len; i++) {
        A_f** method_args = &mem->args.arg_0;
        A_f* arg_type = method_args[i];
        arg_values[i] = (arg_type->traits & ((1 << 0) | (1 << 1))) ?
            (void*)args->elements[i] : (void*)&args->elements[i];
    }

    void* result[8];
    ffi_call((ffi_cif*)mem->method->ffi_cif, mem->method->address, result, arg_values);
    if (mem->type->traits & (1 << 0))
        return A_primitive(mem->type, result);
    else if (mem->type->traits & (1 << 1))
        return A_enum(mem->type, *(i32*)result);
    else
        return (A) result[0];
}



A A_hold (A a) { ++a->refs; return a; }
static A A_default (A_t type, num count) {
    return A_alloc(type, count);
}
static void A_init (A a) { }
static void A_destructor(A a) { }
static u64 A_hash (A a) { return (u64)(size_t)a; }
static bool A_boolean (A a) { return (bool)(size_t)a; }


static i32 A_compare(A a, A b) {
    return (i32)(a - b);
}

static void string_init(string a) { printf("init string\n"); }
static void string_destructor(string a) { free(a->chars); }
static num string_compare(string a, string b) { return strcmp(a->chars, b->chars); }
static array string_split(string a, A sp) {
    return ((void*)0);
}
static num string_index_of(string a, cstr cs) {
    char* f = strstr(a->chars, cs);
    return f ? (num)(f - a->chars) : (num)-1;
}

u64 fnv1a_hash(const void* data, size_t length, u64 hash) {
    const u8* bytes = (const u8*)data;
    for (size_t i = 0; i < length; ++i) {
        hash ^= bytes[i];
        hash *= 0x100000001b3;
    }
    return hash;
}

static u64 string_hash(string a) {
    if (a->h) return a->h;
    a->h = fnv1a_hash(a->chars, a->len, 0xcbf29ce484222325);
    return a->h;
}

string string_of_reserve(string a, num sz) {
    a->alloc = sz;
    a->chars = (char*)calloc(1, a->alloc);
    return a;
}
# 249 "../silver/A.c"
string string_of_cstr(string a, cstr value, num len) {
    if (len == -1) len = strlen(value);
    a->alloc = len + 1;
    a->len = len;
    a->chars = (char*)calloc(1, a->alloc);
    memcpy(a->chars, value, len);
    a->chars[len] = 0;
    return a;
}

string string_of_file(string a, cstr file) {
    FILE* f = fopen(file, "rb");
    if (!f) return ((void*)0);
    fseek(f, 0, 
# 262 "../silver/A.c" 3 4
               2
# 262 "../silver/A.c"
                       );
    num flen = ftell(f);
    fseek(f, 0, 
# 264 "../silver/A.c" 3 4
               0
# 264 "../silver/A.c"
                       );
    cstr alloc = calloc(flen + 1, 1);
    size_t n = fread(alloc, 1, flen, f);
    
# 267 "../silver/A.c" 3 4
   ((void) sizeof ((
# 267 "../silver/A.c"
   n == flen
# 267 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 267 "../silver/A.c"
   n == flen
# 267 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 267 "../silver/A.c"
   "n == flen"
# 267 "../silver/A.c" 3 4
   , "../silver/A.c", 267, __extension__ __PRETTY_FUNCTION__); }))
# 267 "../silver/A.c"
                    ;
    alloc[flen] = 0;
    a->alloc = flen + 1;
    a->len = flen;
    a->chars = alloc;
    return a;
}


static void collection_push(collection a, A b) {
    
# 277 "../silver/A.c" 3 4
   ((void) sizeof ((
# 277 "../silver/A.c"
   (bool)0
# 277 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 277 "../silver/A.c"
   (bool)0
# 277 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 277 "../silver/A.c"
   "false"
# 277 "../silver/A.c" 3 4
   , "../silver/A.c", 277, __extension__ __PRETTY_FUNCTION__); }))
# 277 "../silver/A.c"
                ;
}

static A collection_pop(collection a) {
    
# 281 "../silver/A.c" 3 4
   ((void) sizeof ((
# 281 "../silver/A.c"
   (bool)0
# 281 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 281 "../silver/A.c"
   (bool)0
# 281 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 281 "../silver/A.c"
   "false"
# 281 "../silver/A.c" 3 4
   , "../silver/A.c", 281, __extension__ __PRETTY_FUNCTION__); }))
# 281 "../silver/A.c"
                ;
    return ((void*)0);
}

static num collection_compare(array a, collection b) {
    
# 286 "../silver/A.c" 3 4
   ((void) sizeof ((
# 286 "../silver/A.c"
   (bool)0
# 286 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 286 "../silver/A.c"
   (bool)0
# 286 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 286 "../silver/A.c"
   "false"
# 286 "../silver/A.c" 3 4
   , "../silver/A.c", 286, __extension__ __PRETTY_FUNCTION__); }))
# 286 "../silver/A.c"
                ;
    return 0;
}

A hold(A a) {
    (a - 1)->refs++;
    return a;
}

void drop(A a) {
    if (--(a - 1)->refs == -1) {
        A aa = (a - 1);
        A_f* type = aa->type;
        void* prev = ((void*)0);
        while (type) {
            if (prev != type->destructor) {
                type->destructor(a);
                prev = type->destructor;
            }
            if (type == &A_type)
                break;
            type = type->parent;
        }
        free(aa);
    }
}

A object(A instance) {
    return (instance - 1)->origin;
}

A data(A instance) {
    A obj = object(instance);
    return obj->data;
}


static void list_push(list a, A e) {
    item n = ((item)A_alloc(((struct A_f*)&item_type), 1));
    n->element = e;
    if (a->last) {
        a->last->next = n;
        n->prev = a->last;
    } else {
        a->first = n;
    }
    a->last = n;
    a->count++;
}

static num list_compare(list a, list b) {
    num diff = a->count - b->count;
    if (diff != 0)
        return diff;
    for (item ai = a->first, bi = b->first; ai; ai = ai->next, bi = bi->next) {
        A_f* ai_t = *(A_f**)&((A)ai->element)[-1];
        num cmp = ai_t->compare(ai, bi);
        if (cmp != 0) return cmp;
    }
    return 0;
}

static A list_pop(list a) {
    item l = a->last;
    a->last = a->last->prev;
    if (!a->last)
        a->first = ((void*)0);
    l->prev = ((void*)0);
    a->count--;
    return l;
}

static A list_get(list a, num at_index) {
    num index = 0;
    for (item i = a->first; i; i = i->next) {
        if (at_index == index)
            return i->element;
        index++;
    }
    
# 365 "../silver/A.c" 3 4
   ((void) sizeof ((
# 365 "../silver/A.c"
   (bool)0
# 365 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 365 "../silver/A.c"
   (bool)0
# 365 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 365 "../silver/A.c"
   "false"
# 365 "../silver/A.c" 3 4
   , "../silver/A.c", 365, __extension__ __PRETTY_FUNCTION__); }))
# 365 "../silver/A.c"
                ;
    return ((void*)0);
}

static num list_count(list a) {
    return a->count;
}


static void array_expand(array a) {
    num alloc = 32 + (a->alloc << 1);
    A* elements = (A*)calloc(alloc, sizeof(struct A*));
    memcpy(elements, a->elements, sizeof(struct A*) * a->len);
    free(a->elements);
    a->elements = elements;
    a->alloc = alloc;
}

static void array_push(array a, A b) {
    if (a->alloc == a->len) {
        array_expand(a);
    }
    a->elements[a->len++] = b;
}

static void array_push_symbols(array a, char* f, ...) {
    va_list args;
    
# 392 "../silver/A.c" 3 4
   __builtin_va_start(
# 392 "../silver/A.c"
   args
# 392 "../silver/A.c" 3 4
   ,
# 392 "../silver/A.c"
   f
# 392 "../silver/A.c" 3 4
   )
# 392 "../silver/A.c"
                    ;
    char* value;
    while ((value = 
# 394 "../silver/A.c" 3 4
                   __builtin_va_arg(
# 394 "../silver/A.c"
                   args
# 394 "../silver/A.c" 3 4
                   ,
# 394 "../silver/A.c"
                   char*
# 394 "../silver/A.c" 3 4
                   )
# 394 "../silver/A.c"
                                      ) != ((void*)0)) {
        string s = string_new.string_of_cstr(((string)A_alloc(((struct A_f*)&string_type), 1)), value, strlen(value));
        ((array_f*)((A)a)[-1].type) -> push(a, s);
    }
    
# 398 "../silver/A.c" 3 4
   __builtin_va_end(
# 398 "../silver/A.c"
   args
# 398 "../silver/A.c" 3 4
   )
# 398 "../silver/A.c"
               ;
}

static void array_push_objects(array a, A f, ...) {
    va_list args;
    
# 403 "../silver/A.c" 3 4
   __builtin_va_start(
# 403 "../silver/A.c"
   args
# 403 "../silver/A.c" 3 4
   ,
# 403 "../silver/A.c"
   f
# 403 "../silver/A.c" 3 4
   )
# 403 "../silver/A.c"
                    ;
    A value;
    while ((value = 
# 405 "../silver/A.c" 3 4
                   __builtin_va_arg(
# 405 "../silver/A.c"
                   args
# 405 "../silver/A.c" 3 4
                   ,
# 405 "../silver/A.c"
                   A
# 405 "../silver/A.c" 3 4
                   )
# 405 "../silver/A.c"
                                  ) != ((void*)0))
        ((array_f*)((A)a)[-1].type) -> push(a, hold(value));
    
# 407 "../silver/A.c" 3 4
   __builtin_va_end(
# 407 "../silver/A.c"
   args
# 407 "../silver/A.c" 3 4
   )
# 407 "../silver/A.c"
               ;
}

static A array_pop(array a) {
    
# 411 "../silver/A.c" 3 4
   ((void) sizeof ((
# 411 "../silver/A.c"
   a->len > 0
# 411 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 411 "../silver/A.c"
   a->len > 0
# 411 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 411 "../silver/A.c"
   "a->len > 0"
# 411 "../silver/A.c" 3 4
   , "../silver/A.c", 411, __extension__ __PRETTY_FUNCTION__); }))
# 411 "../silver/A.c"
                     ;
    return a->elements[a->len--];
}

static num array_compare(array a, array b) {
    num diff = a->len - b->len;
    if (diff != 0)
        return diff;
    for (num i = 0; i < a->len; i++) {
        num cmp = ((A_f*)((A)a->elements[i])[-1].type) -> compare(a->elements[i], b->elements[i]);
        if (cmp != 0)
            return cmp;
    }
    return 0;
}

static A array_get(array a, num i) {
    return a->elements[i];
}

static num array_count(array a) {
    return a->len;
}


static num array_index_of(array a, A b) {
    for (num i = 0; i < a->len; i++) {
        if (a -> elements[i] == b)
            return i;
    }
    return -1;
}

static bool array_boolean(array a) { return a && a->len > 0; }

static void vector_push(vector a, A b) {
    A obj = object(a);
    if (obj->alloc == obj->count)
        A_realloc(obj, 32 + (obj->alloc < 1));
    u8* dst = obj->data;
    num sz = obj->type->size;
    memcpy(&dst[sz * obj->count++], b, sz);
}



static A vector_pop(vector a) {
    A obj = object(a);
    
# 459 "../silver/A.c" 3 4
   ((void) sizeof ((
# 459 "../silver/A.c"
   obj->count > 0
# 459 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 459 "../silver/A.c"
   obj->count > 0
# 459 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 459 "../silver/A.c"
   "obj->count > 0"
# 459 "../silver/A.c" 3 4
   , "../silver/A.c", 459, __extension__ __PRETTY_FUNCTION__); }))
# 459 "../silver/A.c"
                         ;
    u8* dst = obj->data;
    num sz = obj->type->size;
    return (A)&dst[sz * --obj->count];
}

static num vector_compare(vector a, vector b) {
    A a_object = object(a);
    A b_object = object(b);
    num diff = a_object->count - b_object->count;
    if (diff != 0)
        return diff;
    
# 471 "../silver/A.c" 3 4
   ((void) sizeof ((
# 471 "../silver/A.c"
   a_object->type == b_object->type
# 471 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 471 "../silver/A.c"
   a_object->type == b_object->type
# 471 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 471 "../silver/A.c"
   "a_object->type == b_object->type"
# 471 "../silver/A.c" 3 4
   , "../silver/A.c", 471, __extension__ __PRETTY_FUNCTION__); }))
# 471 "../silver/A.c"
                                           ;
    u8* a_data = data(a);
    u8* b_data = data(b);
    num sz = a_object->type->size;
    for (num i = 0; i < a_object->count; i++) {
        num cmp = memcmp(&a_data[sz * i], &b_data[sz * i], sz);
        if (cmp != 0)
            return cmp;
    }
    return 0;
}

static A vector_get(vector a, num i) {
    A a_object = object(a);
    u8* a_data = data(a);
    num sz = a_object->type->size;
    return (A)&a_data[i * sz];
}

static num vector_count(vector a) {
    A a_object = object(a);
    return a_object->count;
}

static num vector_index_of(vector a, A b) {
    A a_object = object(a);
    u8* a_data = data(a);
    u8* b_data = data(b);
    num sz = a_object->type->size;
    for (num i = 0; i < a_object->count; i++) {
        if (memcmp(&a_data[sz * i], b_data, sz) == 0)
            return i;
    }
    return -1;
}

static bool vector_boolean(vector a) {
    A a_object = object(a);
    return a_object->count > 0;
}

u64 vector_hash(vector a) {
    A obj = object(a);
    return fnv1a_hash(obj->data, obj->type->size * obj->count, 0xcbf29ce484222325);
}



A_ctr A_new; A_f A_type; static __attribute__((constructor)) bool global_A() { A_f* type_ref = &A_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_A); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(A_type) / sizeof(void*)]; A_type.parent = & A_type; A_type.name = "A"; A_type.size = sizeof(struct A); A_type.members = members; A_type.traits = 0; A_type.arb = &ffi_type_pointer; A_type.factory = &A_new; A_new . A_default = & A_default; 
# 519 "../silver/A.c" 3 4
((void) sizeof ((
# 519 "../silver/A.c"
"A" == "A"
# 519 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 519 "../silver/A.c"
"A" == "A"
# 519 "../silver/A.c" 3 4
) ; else __assert_fail (
# 519 "../silver/A.c"
"\"A\" == \"A\""
# 519 "../silver/A.c" 3 4
, "../silver/A.c", 519, __extension__ __PRETTY_FUNCTION__); }))
# 519 "../silver/A.c"
; A_type.members[A_type.member_count].name = "default"; A_type.members[A_type.member_count].args = (args_t) { 1, &A_type }; A_type.members[A_type.member_count].type = &A_type; A_type.members[A_type.member_count].offset = 
# 519 "../silver/A.c" 3 4
__builtin_offsetof (
# 519 "../silver/A.c"
A_ctr
# 519 "../silver/A.c" 3 4
, 
# 519 "../silver/A.c"
A_default
# 519 "../silver/A.c" 3 4
)
# 519 "../silver/A.c"
; A_type.members[A_type.member_count].member_type = A_TYPE_CONSTRUCT; A_type.member_count++; A_type . init = & A_init; A_type.members[A_type.member_count].name = "init"; A_type.members[A_type.member_count].args = (args_t) { 1, &A_type }; A_type.members[A_type.member_count].type = &none_type; A_type.members[A_type.member_count].offset = 
# 519 "../silver/A.c" 3 4
__builtin_offsetof (
# 519 "../silver/A.c"
A_f
# 519 "../silver/A.c" 3 4
, 
# 519 "../silver/A.c"
init
# 519 "../silver/A.c" 3 4
)
# 519 "../silver/A.c"
; A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type . destructor = & A_destructor; A_type.members[A_type.member_count].name = "destructor"; A_type.members[A_type.member_count].args = (args_t) { 1, &A_type }; A_type.members[A_type.member_count].type = &none_type; A_type.members[A_type.member_count].offset = 
# 519 "../silver/A.c" 3 4
__builtin_offsetof (
# 519 "../silver/A.c"
A_f
# 519 "../silver/A.c" 3 4
, 
# 519 "../silver/A.c"
destructor
# 519 "../silver/A.c" 3 4
)
# 519 "../silver/A.c"
; A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type . compare = & A_compare; A_type.members[A_type.member_count].name = "compare"; A_type.members[A_type.member_count].args = (args_t) { 2, &A_type, &A_type }; A_type.members[A_type.member_count].type = &i32_type; A_type.members[A_type.member_count].offset = 
# 519 "../silver/A.c" 3 4
__builtin_offsetof (
# 519 "../silver/A.c"
A_f
# 519 "../silver/A.c" 3 4
, 
# 519 "../silver/A.c"
compare
# 519 "../silver/A.c" 3 4
)
# 519 "../silver/A.c"
; A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type . hash = & A_hash; A_type.members[A_type.member_count].name = "hash"; A_type.members[A_type.member_count].args = (args_t) { 1, &A_type }; A_type.members[A_type.member_count].type = &u64_type; A_type.members[A_type.member_count].offset = 
# 519 "../silver/A.c" 3 4
__builtin_offsetof (
# 519 "../silver/A.c"
A_f
# 519 "../silver/A.c" 3 4
, 
# 519 "../silver/A.c"
hash
# 519 "../silver/A.c" 3 4
)
# 519 "../silver/A.c"
; A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type . boolean = & A_boolean; A_type.members[A_type.member_count].name = "boolean"; A_type.members[A_type.member_count].args = (args_t) { 1, &A_type }; A_type.members[A_type.member_count].type = &bool_type; A_type.members[A_type.member_count].offset = 
# 519 "../silver/A.c" 3 4
__builtin_offsetof (
# 519 "../silver/A.c"
A_f
# 519 "../silver/A.c" 3 4
, 
# 519 "../silver/A.c"
boolean
# 519 "../silver/A.c" 3 4
)
# 519 "../silver/A.c"
; A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++;; A_push_type(&A_type); return (bool)1; } }
string_ctr string_new; string_f string_type; static __attribute__((constructor)) bool global_string() { string_f* type_ref = &string_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_string); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(string_type) / sizeof(void*)]; string_type.parent = & A_type; string_type.name = "string"; string_type.size = sizeof(struct string); string_type.members = members; string_type.traits = 0; string_type.arb = &ffi_type_pointer; string_type.factory = &string_new; string_type . split = & string_split; string_type.members[string_type.member_count].name = "split"; string_type.members[string_type.member_count].args = (args_t) { 2, &string_type, &A_type }; string_type.members[string_type.member_count].type = &array_type; string_type.members[string_type.member_count].offset = 
# 520 "../silver/A.c" 3 4
__builtin_offsetof (
# 520 "../silver/A.c"
string_f
# 520 "../silver/A.c" 3 4
, 
# 520 "../silver/A.c"
split
# 520 "../silver/A.c" 3 4
)
# 520 "../silver/A.c"
; string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_type . index_of = & string_index_of; string_type.members[string_type.member_count].name = "index_of"; string_type.members[string_type.member_count].args = (args_t) { 2, &string_type, &cstr_type }; string_type.members[string_type.member_count].type = &num_type; string_type.members[string_type.member_count].offset = 
# 520 "../silver/A.c" 3 4
__builtin_offsetof (
# 520 "../silver/A.c"
string_f
# 520 "../silver/A.c" 3 4
, 
# 520 "../silver/A.c"
index_of
# 520 "../silver/A.c" 3 4
)
# 520 "../silver/A.c"
; string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_new . string_of_reserve = & string_of_reserve; 
# 520 "../silver/A.c" 3 4
((void) sizeof ((
# 520 "../silver/A.c"
"string" == "string"
# 520 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 520 "../silver/A.c"
"string" == "string"
# 520 "../silver/A.c" 3 4
) ; else __assert_fail (
# 520 "../silver/A.c"
"\"string\" == \"string\""
# 520 "../silver/A.c" 3 4
, "../silver/A.c", 520, __extension__ __PRETTY_FUNCTION__); }))
# 520 "../silver/A.c"
; string_type.members[string_type.member_count].name = "of_reserve"; string_type.members[string_type.member_count].args = (args_t) { 2, &string_type, &num_type }; string_type.members[string_type.member_count].type = &string_type; string_type.members[string_type.member_count].offset = 
# 520 "../silver/A.c" 3 4
__builtin_offsetof (
# 520 "../silver/A.c"
string_ctr
# 520 "../silver/A.c" 3 4
, 
# 520 "../silver/A.c"
string_of_reserve
# 520 "../silver/A.c" 3 4
)
# 520 "../silver/A.c"
; string_type.members[string_type.member_count].member_type = A_TYPE_CONSTRUCT; string_type.member_count++; string_new . string_of_cstr = & string_of_cstr; 
# 520 "../silver/A.c" 3 4
((void) sizeof ((
# 520 "../silver/A.c"
"string" == "string"
# 520 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 520 "../silver/A.c"
"string" == "string"
# 520 "../silver/A.c" 3 4
) ; else __assert_fail (
# 520 "../silver/A.c"
"\"string\" == \"string\""
# 520 "../silver/A.c" 3 4
, "../silver/A.c", 520, __extension__ __PRETTY_FUNCTION__); }))
# 520 "../silver/A.c"
; string_type.members[string_type.member_count].name = "of_cstr"; string_type.members[string_type.member_count].args = (args_t) { 3, &string_type, &cstr_type, &num_type }; string_type.members[string_type.member_count].type = &string_type; string_type.members[string_type.member_count].offset = 
# 520 "../silver/A.c" 3 4
__builtin_offsetof (
# 520 "../silver/A.c"
string_ctr
# 520 "../silver/A.c" 3 4
, 
# 520 "../silver/A.c"
string_of_cstr
# 520 "../silver/A.c" 3 4
)
# 520 "../silver/A.c"
; string_type.members[string_type.member_count].member_type = A_TYPE_CONSTRUCT; string_type.member_count++; string_new . string_of_file = & string_of_file; 
# 520 "../silver/A.c" 3 4
((void) sizeof ((
# 520 "../silver/A.c"
"string" == "string"
# 520 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 520 "../silver/A.c"
"string" == "string"
# 520 "../silver/A.c" 3 4
) ; else __assert_fail (
# 520 "../silver/A.c"
"\"string\" == \"string\""
# 520 "../silver/A.c" 3 4
, "../silver/A.c", 520, __extension__ __PRETTY_FUNCTION__); }))
# 520 "../silver/A.c"
; string_type.members[string_type.member_count].name = "of_file"; string_type.members[string_type.member_count].args = (args_t) { 2, &string_type, &cstr_type }; string_type.members[string_type.member_count].type = &string_type; string_type.members[string_type.member_count].offset = 
# 520 "../silver/A.c" 3 4
__builtin_offsetof (
# 520 "../silver/A.c"
string_ctr
# 520 "../silver/A.c" 3 4
, 
# 520 "../silver/A.c"
string_of_file
# 520 "../silver/A.c" 3 4
)
# 520 "../silver/A.c"
; string_type.members[string_type.member_count].member_type = A_TYPE_CONSTRUCT; string_type.member_count++; string_type . hash = & string_hash;; A_push_type(&string_type); return (bool)1; } }
item_ctr item_new; item_f item_type; static __attribute__((constructor)) bool global_item() { item_f* type_ref = &item_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_item); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(item_type) / sizeof(void*)]; item_type.parent = & A_type; item_type.name = "item"; item_type.size = sizeof(struct item); item_type.members = members; item_type.traits = 0; item_type.arb = &ffi_type_pointer; item_type.factory = &item_new; ; A_push_type(&item_type); return (bool)1; } }
collection_f collection_type; static __attribute__((constructor)) bool global_collection() { collection_f* type_ref = &collection_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_collection); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(collection_type) / sizeof(void*)]; collection_type.parent = & A_type; collection_type.name = "collection"; collection_type.size = sizeof(struct collection); collection_type.members = members; collection_type.traits = 0; ; A_push_type(&collection_type); return (bool)1; } }
list_ctr list_new; list_f list_type; static __attribute__((constructor)) bool global_list() { list_f* type_ref = &list_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_list); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(list_type) / sizeof(void*)]; list_type.parent = & A_type; list_type.name = "list"; list_type.size = sizeof(struct list); list_type.members = members; list_type.traits = 0; list_type.arb = &ffi_type_pointer; list_type.factory = &list_new; list_type.members[list_type.member_count].name = "public_integer"; list_type.members[list_type.member_count].offset = 
# 523 "../silver/A.c" 3 4
__builtin_offsetof (
# 523 "../silver/A.c"
struct list
# 523 "../silver/A.c" 3 4
, 
# 523 "../silver/A.c"
public_integer
# 523 "../silver/A.c" 3 4
)
# 523 "../silver/A.c"
; list_type.members[list_type.member_count].type = &i32_type; list_type.members[list_type.member_count].member_type = A_TYPE_PROP; list_type.member_count++; list_type . pop = & list_pop; list_type.members[list_type.member_count].name = "pop"; list_type.members[list_type.member_count].args = (args_t) { 1, &list_type }; list_type.members[list_type.member_count].type = &A_type; list_type.members[list_type.member_count].offset = 
# 523 "../silver/A.c" 3 4
__builtin_offsetof (
# 523 "../silver/A.c"
list_f
# 523 "../silver/A.c" 3 4
, 
# 523 "../silver/A.c"
pop
# 523 "../silver/A.c" 3 4
)
# 523 "../silver/A.c"
; list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . push = & list_push; list_type.members[list_type.member_count].name = "push"; list_type.members[list_type.member_count].args = (args_t) { 2, &list_type, &A_type }; list_type.members[list_type.member_count].type = &none_type; list_type.members[list_type.member_count].offset = 
# 523 "../silver/A.c" 3 4
__builtin_offsetof (
# 523 "../silver/A.c"
list_f
# 523 "../silver/A.c" 3 4
, 
# 523 "../silver/A.c"
push
# 523 "../silver/A.c" 3 4
)
# 523 "../silver/A.c"
; list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . get = & list_get; list_type.members[list_type.member_count].name = "get"; list_type.members[list_type.member_count].args = (args_t) { 2, &list_type, &i32_type }; list_type.members[list_type.member_count].type = &A_type; list_type.members[list_type.member_count].offset = 
# 523 "../silver/A.c" 3 4
__builtin_offsetof (
# 523 "../silver/A.c"
list_f
# 523 "../silver/A.c" 3 4
, 
# 523 "../silver/A.c"
get
# 523 "../silver/A.c" 3 4
)
# 523 "../silver/A.c"
; list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . count = & list_count; list_type.members[list_type.member_count].name = "count"; list_type.members[list_type.member_count].args = (args_t) { 1, &list_type }; list_type.members[list_type.member_count].type = &num_type; list_type.members[list_type.member_count].offset = 
# 523 "../silver/A.c" 3 4
__builtin_offsetof (
# 523 "../silver/A.c"
list_f
# 523 "../silver/A.c" 3 4
, 
# 523 "../silver/A.c"
count
# 523 "../silver/A.c" 3 4
)
# 523 "../silver/A.c"
; list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++;; A_push_type(&list_type); return (bool)1; } }
array_ctr array_new; array_f array_type; static __attribute__((constructor)) bool global_array() { array_f* type_ref = &array_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_array); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(array_type) / sizeof(void*)]; array_type.parent = & A_type; array_type.name = "array"; array_type.size = sizeof(struct array); array_type.members = members; array_type.traits = 0; array_type.arb = &ffi_type_pointer; array_type.factory = &array_new; array_type . pop = & array_pop; array_type.members[array_type.member_count].name = "pop"; array_type.members[array_type.member_count].args = (args_t) { 1, &array_type }; array_type.members[array_type.member_count].type = &array_type; array_type.members[array_type.member_count].offset = 
# 524 "../silver/A.c" 3 4
__builtin_offsetof (
# 524 "../silver/A.c"
array_f
# 524 "../silver/A.c" 3 4
, 
# 524 "../silver/A.c"
pop
# 524 "../silver/A.c" 3 4
)
# 524 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . push = & array_push; array_type.members[array_type.member_count].name = "push"; array_type.members[array_type.member_count].args = (args_t) { 2, &array_type, &A_type }; array_type.members[array_type.member_count].type = &none_type; array_type.members[array_type.member_count].offset = 
# 524 "../silver/A.c" 3 4
__builtin_offsetof (
# 524 "../silver/A.c"
array_f
# 524 "../silver/A.c" 3 4
, 
# 524 "../silver/A.c"
push
# 524 "../silver/A.c" 3 4
)
# 524 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . get = & array_get; array_type.members[array_type.member_count].name = "get"; array_type.members[array_type.member_count].args = (args_t) { 2, &array_type, &i32_type }; array_type.members[array_type.member_count].type = &A_type; array_type.members[array_type.member_count].offset = 
# 524 "../silver/A.c" 3 4
__builtin_offsetof (
# 524 "../silver/A.c"
array_f
# 524 "../silver/A.c" 3 4
, 
# 524 "../silver/A.c"
get
# 524 "../silver/A.c" 3 4
)
# 524 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . count = & array_count; array_type.members[array_type.member_count].name = "count"; array_type.members[array_type.member_count].args = (args_t) { 1, &array_type }; array_type.members[array_type.member_count].type = &array_type; array_type.members[array_type.member_count].offset = 
# 524 "../silver/A.c" 3 4
__builtin_offsetof (
# 524 "../silver/A.c"
array_f
# 524 "../silver/A.c" 3 4
, 
# 524 "../silver/A.c"
count
# 524 "../silver/A.c" 3 4
)
# 524 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . index_of = & array_index_of; array_type.members[array_type.member_count].name = "index_of"; array_type.members[array_type.member_count].args = (args_t) { 2, &array_type, &A_type }; array_type.members[array_type.member_count].type = &num_type; array_type.members[array_type.member_count].offset = 
# 524 "../silver/A.c" 3 4
__builtin_offsetof (
# 524 "../silver/A.c"
array_f
# 524 "../silver/A.c" 3 4
, 
# 524 "../silver/A.c"
index_of
# 524 "../silver/A.c" 3 4
)
# 524 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . push_symbols = & array_push_symbols; array_type.members[array_type.member_count].name = "push_symbols"; array_type.members[array_type.member_count].args = (args_t) { 2, &array_type, &cstr_type }; array_type.members[array_type.member_count].type = &none_type; array_type.members[array_type.member_count].offset = 
# 524 "../silver/A.c" 3 4
__builtin_offsetof (
# 524 "../silver/A.c"
array_f
# 524 "../silver/A.c" 3 4
, 
# 524 "../silver/A.c"
push_symbols
# 524 "../silver/A.c" 3 4
)
# 524 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . push_objects = & array_push_objects; array_type.members[array_type.member_count].name = "push_objects"; array_type.members[array_type.member_count].args = (args_t) { 2, &array_type, &A_type }; array_type.members[array_type.member_count].type = &none_type; array_type.members[array_type.member_count].offset = 
# 524 "../silver/A.c" 3 4
__builtin_offsetof (
# 524 "../silver/A.c"
array_f
# 524 "../silver/A.c" 3 4
, 
# 524 "../silver/A.c"
push_objects
# 524 "../silver/A.c" 3 4
)
# 524 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . boolean = & array_boolean;; A_push_type(&array_type); return (bool)1; } }
vector_ctr vector_new; vector_f vector_type; static __attribute__((constructor)) bool global_vector() { vector_f* type_ref = &vector_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_vector); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(vector_type) / sizeof(void*)]; vector_type.parent = & A_type; vector_type.name = "vector"; vector_type.size = sizeof(struct vector); vector_type.members = members; vector_type.traits = 0; vector_type.arb = &ffi_type_pointer; vector_type.factory = &vector_new; vector_type . pop = & vector_pop; vector_type.members[vector_type.member_count].name = "pop"; vector_type.members[vector_type.member_count].args = (args_t) { 1, &vector_type }; vector_type.members[vector_type.member_count].type = &A_type; vector_type.members[vector_type.member_count].offset = 
# 525 "../silver/A.c" 3 4
__builtin_offsetof (
# 525 "../silver/A.c"
vector_f
# 525 "../silver/A.c" 3 4
, 
# 525 "../silver/A.c"
pop
# 525 "../silver/A.c" 3 4
)
# 525 "../silver/A.c"
; vector_type.members[vector_type.member_count].member_type = A_TYPE_IMETHOD; vector_type.member_count++; vector_type . push = & vector_push; vector_type.members[vector_type.member_count].name = "push"; vector_type.members[vector_type.member_count].args = (args_t) { 2, &vector_type, &A_type }; vector_type.members[vector_type.member_count].type = &none_type; vector_type.members[vector_type.member_count].offset = 
# 525 "../silver/A.c" 3 4
__builtin_offsetof (
# 525 "../silver/A.c"
vector_f
# 525 "../silver/A.c" 3 4
, 
# 525 "../silver/A.c"
push
# 525 "../silver/A.c" 3 4
)
# 525 "../silver/A.c"
; vector_type.members[vector_type.member_count].member_type = A_TYPE_IMETHOD; vector_type.member_count++; vector_type . get = & vector_get; vector_type.members[vector_type.member_count].name = "get"; vector_type.members[vector_type.member_count].args = (args_t) { 2, &vector_type, &i32_type }; vector_type.members[vector_type.member_count].type = &A_type; vector_type.members[vector_type.member_count].offset = 
# 525 "../silver/A.c" 3 4
__builtin_offsetof (
# 525 "../silver/A.c"
vector_f
# 525 "../silver/A.c" 3 4
, 
# 525 "../silver/A.c"
get
# 525 "../silver/A.c" 3 4
)
# 525 "../silver/A.c"
; vector_type.members[vector_type.member_count].member_type = A_TYPE_IMETHOD; vector_type.member_count++; vector_type . count = & vector_count; vector_type.members[vector_type.member_count].name = "count"; vector_type.members[vector_type.member_count].args = (args_t) { 1, &vector_type }; vector_type.members[vector_type.member_count].type = &num_type; vector_type.members[vector_type.member_count].offset = 
# 525 "../silver/A.c" 3 4
__builtin_offsetof (
# 525 "../silver/A.c"
vector_f
# 525 "../silver/A.c" 3 4
, 
# 525 "../silver/A.c"
count
# 525 "../silver/A.c" 3 4
)
# 525 "../silver/A.c"
; vector_type.members[vector_type.member_count].member_type = A_TYPE_IMETHOD; vector_type.member_count++; vector_type . compare = & vector_compare; vector_type . hash = & vector_hash; vector_type . boolean = & vector_boolean;; A_push_type(&vector_type); return (bool)1; } }

u8_f u8_type; static __attribute__((constructor)) bool global_u8() { u8_f* type_ref = &u8_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_u8); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(u8_type) / sizeof(void*)]; u8_type.parent = & A_type; u8_type.name = "u8"; u8_type.size = sizeof(u8); u8_type.members = members; u8_type.traits = (1 << 0); u8_type.arb = &ffi_type_uint8; u8_type.factory = &A_new;; A_push_type(&u8_type); return (bool)1; } }
u16_f u16_type; static __attribute__((constructor)) bool global_u16() { u16_f* type_ref = &u16_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_u16); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(u16_type) / sizeof(void*)]; u16_type.parent = & A_type; u16_type.name = "u16"; u16_type.size = sizeof(u16); u16_type.members = members; u16_type.traits = (1 << 0); u16_type.arb = &ffi_type_uint16; u16_type.factory = &A_new;; A_push_type(&u16_type); return (bool)1; } }
u32_f u32_type; static __attribute__((constructor)) bool global_u32() { u32_f* type_ref = &u32_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_u32); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(u32_type) / sizeof(void*)]; u32_type.parent = & A_type; u32_type.name = "u32"; u32_type.size = sizeof(u32); u32_type.members = members; u32_type.traits = (1 << 0); u32_type.arb = &ffi_type_uint32; u32_type.factory = &A_new;; A_push_type(&u32_type); return (bool)1; } }
u64_f u64_type; static __attribute__((constructor)) bool global_u64() { u64_f* type_ref = &u64_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_u64); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(u64_type) / sizeof(void*)]; u64_type.parent = & A_type; u64_type.name = "u64"; u64_type.size = sizeof(u64); u64_type.members = members; u64_type.traits = (1 << 0); u64_type.arb = &ffi_type_uint64; u64_type.factory = &A_new;; A_push_type(&u64_type); return (bool)1; } }
i8_f i8_type; static __attribute__((constructor)) bool global_i8() { i8_f* type_ref = &i8_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_i8); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(i8_type) / sizeof(void*)]; i8_type.parent = & A_type; i8_type.name = "i8"; i8_type.size = sizeof(i8); i8_type.members = members; i8_type.traits = (1 << 0); i8_type.arb = &ffi_type_sint8; i8_type.factory = &A_new;; A_push_type(&i8_type); return (bool)1; } }
i16_f i16_type; static __attribute__((constructor)) bool global_i16() { i16_f* type_ref = &i16_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_i16); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(i16_type) / sizeof(void*)]; i16_type.parent = & A_type; i16_type.name = "i16"; i16_type.size = sizeof(i16); i16_type.members = members; i16_type.traits = (1 << 0); i16_type.arb = &ffi_type_sint16; i16_type.factory = &A_new;; A_push_type(&i16_type); return (bool)1; } }
i32_f i32_type; static __attribute__((constructor)) bool global_i32() { i32_f* type_ref = &i32_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_i32); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(i32_type) / sizeof(void*)]; i32_type.parent = & A_type; i32_type.name = "i32"; i32_type.size = sizeof(i32); i32_type.members = members; i32_type.traits = (1 << 0); i32_type.arb = &ffi_type_sint32; i32_type.factory = &A_new;; A_push_type(&i32_type); return (bool)1; } }
i64_f i64_type; static __attribute__((constructor)) bool global_i64() { i64_f* type_ref = &i64_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_i64); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(i64_type) / sizeof(void*)]; i64_type.parent = & A_type; i64_type.name = "i64"; i64_type.size = sizeof(i64); i64_type.members = members; i64_type.traits = (1 << 0); i64_type.arb = &ffi_type_sint64; i64_type.factory = &A_new;; A_push_type(&i64_type); return (bool)1; } }
f32_f f32_type; static __attribute__((constructor)) bool global_f32() { f32_f* type_ref = &f32_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_f32); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(f32_type) / sizeof(void*)]; f32_type.parent = & A_type; f32_type.name = "f32"; f32_type.size = sizeof(f32); f32_type.members = members; f32_type.traits = (1 << 0); f32_type.arb = &ffi_type_float; f32_type.factory = &A_new;; A_push_type(&f32_type); return (bool)1; } }
f64_f f64_type; static __attribute__((constructor)) bool global_f64() { f64_f* type_ref = &f64_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_f64); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(f64_type) / sizeof(void*)]; f64_type.parent = & A_type; f64_type.name = "f64"; f64_type.size = sizeof(f64); f64_type.members = members; f64_type.traits = (1 << 0); f64_type.arb = &ffi_type_double; f64_type.factory = &A_new;; A_push_type(&f64_type); return (bool)1; } }
f128_f f128_type; static __attribute__((constructor)) bool global_f128() { f128_f* type_ref = &f128_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_f128); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(f128_type) / sizeof(void*)]; f128_type.parent = & A_type; f128_type.name = "f128"; f128_type.size = sizeof(f128); f128_type.members = members; f128_type.traits = (1 << 0); f128_type.arb = &ffi_type_longdouble; f128_type.factory = &A_new;; A_push_type(&f128_type); return (bool)1; } }
cstr_f cstr_type; static __attribute__((constructor)) bool global_cstr() { cstr_f* type_ref = &cstr_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_cstr); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(cstr_type) / sizeof(void*)]; cstr_type.parent = & A_type; cstr_type.name = "cstr"; cstr_type.size = sizeof(cstr); cstr_type.members = members; cstr_type.traits = (1 << 0); cstr_type.arb = &ffi_type_pointer; cstr_type.factory = &A_new;; A_push_type(&cstr_type); return (bool)1; } }
bool_f bool_type; static __attribute__((constructor)) bool global_bool() { bool_f* type_ref = &bool_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_bool); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(bool_type) / sizeof(void*)]; bool_type.parent = & A_type; bool_type.name = "bool"; bool_type.size = sizeof(bool); bool_type.members = members; bool_type.traits = (1 << 0); bool_type.arb = &ffi_type_uint32; bool_type.factory = &A_new;; A_push_type(&bool_type); return (bool)1; } }
num_f num_type; static __attribute__((constructor)) bool global_num() { num_f* type_ref = &num_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_num); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(num_type) / sizeof(void*)]; num_type.parent = & A_type; num_type.name = "num"; num_type.size = sizeof(num); num_type.members = members; num_type.traits = (1 << 0); num_type.arb = &ffi_type_sint64; num_type.factory = &A_new;; A_push_type(&num_type); return (bool)1; } }
none_f none_type; static __attribute__((constructor)) bool global_none() { none_f* type_ref = &none_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_none); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(none_type) / sizeof(void*)]; none_type.parent = & A_type; none_type.name = "none"; none_type.size = sizeof(none); none_type.members = members; none_type.traits = (1 << 0); none_type.arb = &ffi_type_void; none_type.factory = &A_new;; A_push_type(&none_type); return (bool)1; } }
AType_f AType_type; static __attribute__((constructor)) bool global_AType() { AType_f* type_ref = &AType_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_AType); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(AType_type) / sizeof(void*)]; AType_type.parent = & A_type; AType_type.name = "AType"; AType_type.size = sizeof(AType); AType_type.members = members; AType_type.traits = (1 << 0); AType_type.arb = &ffi_type_pointer; AType_type.factory = &A_new;; A_push_type(&AType_type); return (bool)1; } }
# 582 "../silver/A.c"
typedef enum EType { EType_Undefined, EType_Statements, EType_Assign, EType_AssignAdd, EType_AssignSub, EType_AssignMul, EType_AssignDiv, EType_AssignOr, EType_AssignAnd, EType_AssignXor, EType_AssignShiftR, EType_AssignShiftL, EType_AssignMod, EType_If, EType_For, EType_While, EType_DoWhile, EType_Break, EType_LiteralReal, EType_LiteralInt, EType_LiteralStr, EType_LiteralStrInterp, EType_Array, EType_AlphaIdent, EType_Var, EType_Add, EType_Sub, EType_Mul, EType_Div, EType_Or, EType_And, EType_Xor, EType_MethodCall, EType_MethodReturn, } EType; typedef struct EType_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(EType); none (*destructor)(EType); i32 (*compare)(EType,EType); u64 (*hash)(EType); bool (*boolean)(EType); } EType_f, *EType_t; extern EType_f EType_type;

EType_f EType_type; static __attribute__((constructor)) bool global_EType() { EType_f* type_ref = &EType_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_EType); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(EType_type) / sizeof(void*)]; EType_type.parent = & A_type; EType_type.name = "EType"; EType_type.size = sizeof(enum EType); EType_type.members = members; EType_type.traits = (1 << 1); EType_type.arb = &ffi_type_sint32; EType_type.members[EType_type.member_count].name = "Undefined"; EType_type.members[EType_type.member_count].offset = EType_Undefined; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Statements"; EType_type.members[EType_type.member_count].offset = EType_Statements; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Assign"; EType_type.members[EType_type.member_count].offset = EType_Assign; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignAdd"; EType_type.members[EType_type.member_count].offset = EType_AssignAdd; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignSub"; EType_type.members[EType_type.member_count].offset = EType_AssignSub; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignMul"; EType_type.members[EType_type.member_count].offset = EType_AssignMul; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignDiv"; EType_type.members[EType_type.member_count].offset = EType_AssignDiv; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignOr"; EType_type.members[EType_type.member_count].offset = EType_AssignOr; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignAnd"; EType_type.members[EType_type.member_count].offset = EType_AssignAnd; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignXor"; EType_type.members[EType_type.member_count].offset = EType_AssignXor; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignShiftR"; EType_type.members[EType_type.member_count].offset = EType_AssignShiftR; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignShiftL"; EType_type.members[EType_type.member_count].offset = EType_AssignShiftL; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignMod"; EType_type.members[EType_type.member_count].offset = EType_AssignMod; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "If"; EType_type.members[EType_type.member_count].offset = EType_If; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "For"; EType_type.members[EType_type.member_count].offset = EType_For; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "While"; EType_type.members[EType_type.member_count].offset = EType_While; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "DoWhile"; EType_type.members[EType_type.member_count].offset = EType_DoWhile; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Break"; EType_type.members[EType_type.member_count].offset = EType_Break; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "LiteralReal"; EType_type.members[EType_type.member_count].offset = EType_LiteralReal; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "LiteralInt"; EType_type.members[EType_type.member_count].offset = EType_LiteralInt; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "LiteralStr"; EType_type.members[EType_type.member_count].offset = EType_LiteralStr; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "LiteralStrInterp"; EType_type.members[EType_type.member_count].offset = EType_LiteralStrInterp; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Array"; EType_type.members[EType_type.member_count].offset = EType_Array; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AlphaIdent"; EType_type.members[EType_type.member_count].offset = EType_AlphaIdent; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Var"; EType_type.members[EType_type.member_count].offset = EType_Var; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Add"; EType_type.members[EType_type.member_count].offset = EType_Add; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Sub"; EType_type.members[EType_type.member_count].offset = EType_Sub; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Mul"; EType_type.members[EType_type.member_count].offset = EType_Mul; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Div"; EType_type.members[EType_type.member_count].offset = EType_Div; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Or"; EType_type.members[EType_type.member_count].offset = EType_Or; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "And"; EType_type.members[EType_type.member_count].offset = EType_And; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Xor"; EType_type.members[EType_type.member_count].offset = EType_Xor; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "MethodCall"; EType_type.members[EType_type.member_count].offset = EType_MethodCall; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "MethodReturn"; EType_type.members[EType_type.member_count].offset = EType_MethodReturn; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++;; A_push_type(&EType_type); return (bool)1; } }
# 597 "../silver/A.c"

# 597 "../silver/A.c"
#pragma pack(push, 1)
# 597 "../silver/A.c"
 typedef struct ident { string value; string fname; array members_cache; int line_num; u64 h; } *ident;
# 597 "../silver/A.c"
#pragma pack(pop)
# 597 "../silver/A.c"
 typedef struct ident_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(ident); none (*destructor)(ident); i32 (*compare)(ident,ident); u64 (*hash)(ident); bool (*boolean)(ident); array (*split_members)(ident); EType (*is_numeric)(ident); EType (*is_string)(ident); } ident_f, *ident_t; typedef struct ident_ctr { ident (*ident_default)(struct ident_f*); ident (*ident_of_token)(struct ident_f*, string, string, num); } ident_ctr; extern ident_ctr ident_new; extern ident_f ident_type;

EType ident_is_string(ident a) {
    char* t = a->value->chars;
    return t[0] == '"' ? EType_LiteralStr : t[0] == '\'' ? EType_LiteralStrInterp : EType_Undefined;
}

EType ident_is_numeric(ident a) {
    char* t = a->value->chars;
    return (t[0] >= '0' && t[0] <= '9') ? (strchr(t, '.') ?
        EType_LiteralReal : EType_LiteralInt) : EType_Undefined;
}

u64 ident_hash(ident a) {
    if (!a->h) {
        u64 h = 0xcbf29ce484222325;
            h *= 0x100000001b3;
            h ^= ((string_f*)((A)a->value)[-1].type) -> hash(a->value);
        a->h = h;
    }
    return a->h;
}

array ident_split_members(ident a, A obj) {
    if (!a->members_cache)
        a->members_cache = ((string_f*)((A)a->value)[-1].type) -> split(a->value, obj);
    return a->members_cache;
}

void ident_of_token(ident a, string token, string fname, num line_num) {
    a->value = token;
    a->fname = fname;
    a->line_num = line_num;
}

ident_ctr ident_new; ident_f ident_type; static __attribute__((constructor)) bool global_ident() { ident_f* type_ref = &ident_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_ident); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(ident_type) / sizeof(void*)]; ident_type.parent = & A_type; ident_type.name = "ident"; ident_type.size = sizeof(struct ident); ident_type.members = members; ident_type.traits = 0; ident_type.arb = &ffi_type_pointer; ident_type.factory = &ident_new; ident_type . split_members = & ident_split_members; ident_type.members[ident_type.member_count].name = "split_members"; ident_type.members[ident_type.member_count].args = (args_t) { 1, &ident_type }; ident_type.members[ident_type.member_count].type = &array_type; ident_type.members[ident_type.member_count].offset = 
# 632 "../silver/A.c" 3 4
__builtin_offsetof (
# 632 "../silver/A.c"
ident_f
# 632 "../silver/A.c" 3 4
, 
# 632 "../silver/A.c"
split_members
# 632 "../silver/A.c" 3 4
)
# 632 "../silver/A.c"
; ident_type.members[ident_type.member_count].member_type = A_TYPE_IMETHOD; ident_type.member_count++; ident_type . is_numeric = & ident_is_numeric; ident_type.members[ident_type.member_count].name = "is_numeric"; ident_type.members[ident_type.member_count].args = (args_t) { 1, &ident_type }; ident_type.members[ident_type.member_count].type = &EType_type; ident_type.members[ident_type.member_count].offset = 
# 632 "../silver/A.c" 3 4
__builtin_offsetof (
# 632 "../silver/A.c"
ident_f
# 632 "../silver/A.c" 3 4
, 
# 632 "../silver/A.c"
is_numeric
# 632 "../silver/A.c" 3 4
)
# 632 "../silver/A.c"
; ident_type.members[ident_type.member_count].member_type = A_TYPE_IMETHOD; ident_type.member_count++; ident_type . is_string = & ident_is_string; ident_type.members[ident_type.member_count].name = "is_string"; ident_type.members[ident_type.member_count].args = (args_t) { 1, &ident_type }; ident_type.members[ident_type.member_count].type = &EType_type; ident_type.members[ident_type.member_count].offset = 
# 632 "../silver/A.c" 3 4
__builtin_offsetof (
# 632 "../silver/A.c"
ident_f
# 632 "../silver/A.c" 3 4
, 
# 632 "../silver/A.c"
is_string
# 632 "../silver/A.c" 3 4
)
# 632 "../silver/A.c"
; ident_type.members[ident_type.member_count].member_type = A_TYPE_IMETHOD; ident_type.member_count++; ident_new . ident_of_token = & ident_of_token; 
# 632 "../silver/A.c" 3 4
((void) sizeof ((
# 632 "../silver/A.c"
"ident" == "ident"
# 632 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 632 "../silver/A.c"
"ident" == "ident"
# 632 "../silver/A.c" 3 4
) ; else __assert_fail (
# 632 "../silver/A.c"
"\"ident\" == \"ident\""
# 632 "../silver/A.c" 3 4
, "../silver/A.c", 632, __extension__ __PRETTY_FUNCTION__); }))
# 632 "../silver/A.c"
; ident_type.members[ident_type.member_count].name = "of_token"; ident_type.members[ident_type.member_count].args = (args_t) { 4, &ident_type, &string_type, &string_type, &num_type }; ident_type.members[ident_type.member_count].type = &ident_type; ident_type.members[ident_type.member_count].offset = 
# 632 "../silver/A.c" 3 4
__builtin_offsetof (
# 632 "../silver/A.c"
ident_ctr
# 632 "../silver/A.c" 3 4
, 
# 632 "../silver/A.c"
ident_of_token
# 632 "../silver/A.c" 3 4
)
# 632 "../silver/A.c"
; ident_type.members[ident_type.member_count].member_type = A_TYPE_CONSTRUCT; ident_type.member_count++; ident_type . hash = & ident_hash;; A_push_type(&ident_type); return (bool)1; } }
# 649 "../silver/A.c"

# 649 "../silver/A.c"
#pragma pack(push, 1)
# 649 "../silver/A.c"
 typedef struct enode { EType etype; A value; array operands; array references; } *enode;
# 649 "../silver/A.c"
#pragma pack(pop)
# 649 "../silver/A.c"
 typedef struct enode_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(enode); none (*destructor)(enode); i32 (*compare)(enode,enode); u64 (*hash)(enode); bool (*boolean)(enode); enode (*create_operation)(EType, array, array); enode (*create_value)(EType, A); enode (*method_call)(ident, array); A (*lookup)(array, ident, bool); string (*string_interpolate)(A, array); A (*exec)(enode, array); } enode_f, *enode_t; typedef struct enode_ctr { enode (*enode_default)(struct enode_f*); } enode_ctr; extern enode_ctr enode_new; extern enode_f enode_type;

enode enode_create_operation(EType etype, array ops, array references) {
    return ((void*)0);
}

enode enode_create_value(EType etype, A value) {
    return ((void*)0);
}

enode enode_method_call(EType etype, ident method, array args) {
    return ((void*)0);
}

A enode_lookup(array stack, ident id, bool top_only) {
    return ((void*)0);
}

string enode_string_interpolate(A input, array stack) {
    return ((void*)0);
}

A enode_exec(enode op, array stack) {
    return ((void*)0);
}

bool enode_boolean(enode a) {
    return a->etype != EType_Undefined;
}

enode_ctr enode_new; enode_f enode_type; static __attribute__((constructor)) bool global_enode() { enode_f* type_ref = &enode_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_enode); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(enode_type) / sizeof(void*)]; enode_type.parent = & A_type; enode_type.name = "enode"; enode_type.size = sizeof(struct enode); enode_type.members = members; enode_type.traits = 0; enode_type.arb = &ffi_type_pointer; enode_type.factory = &enode_new; enode_type . create_operation = & enode_create_operation; enode_type.members[enode_type.member_count].name = "create_operation"; enode_type.members[enode_type.member_count].args = (args_t) { 3, &EType_type, &array_type, &array_type }; enode_type.members[enode_type.member_count].type = &enode_type; enode_type.members[enode_type.member_count].offset = 
# 679 "../silver/A.c" 3 4
__builtin_offsetof (
# 679 "../silver/A.c"
enode_f
# 679 "../silver/A.c" 3 4
, 
# 679 "../silver/A.c"
create_operation
# 679 "../silver/A.c" 3 4
)
# 679 "../silver/A.c"
; enode_type.members[enode_type.member_count].member_type = A_TYPE_SMETHOD; enode_type.member_count++; enode_type . create_value = & enode_create_value; enode_type.members[enode_type.member_count].name = "create_value"; enode_type.members[enode_type.member_count].args = (args_t) { 2, &EType_type, &A_type }; enode_type.members[enode_type.member_count].type = &enode_type; enode_type.members[enode_type.member_count].offset = 
# 679 "../silver/A.c" 3 4
__builtin_offsetof (
# 679 "../silver/A.c"
enode_f
# 679 "../silver/A.c" 3 4
, 
# 679 "../silver/A.c"
create_value
# 679 "../silver/A.c" 3 4
)
# 679 "../silver/A.c"
; enode_type.members[enode_type.member_count].member_type = A_TYPE_SMETHOD; enode_type.member_count++; enode_type . method_call = & enode_method_call; enode_type.members[enode_type.member_count].name = "method_call"; enode_type.members[enode_type.member_count].args = (args_t) { 2, &ident_type, &array_type }; enode_type.members[enode_type.member_count].type = &enode_type; enode_type.members[enode_type.member_count].offset = 
# 679 "../silver/A.c" 3 4
__builtin_offsetof (
# 679 "../silver/A.c"
enode_f
# 679 "../silver/A.c" 3 4
, 
# 679 "../silver/A.c"
method_call
# 679 "../silver/A.c" 3 4
)
# 679 "../silver/A.c"
; enode_type.members[enode_type.member_count].member_type = A_TYPE_SMETHOD; enode_type.member_count++; enode_type . lookup = & enode_lookup; enode_type.members[enode_type.member_count].name = "lookup"; enode_type.members[enode_type.member_count].args = (args_t) { 3, &array_type, &ident_type, &bool_type }; enode_type.members[enode_type.member_count].type = &A_type; enode_type.members[enode_type.member_count].offset = 
# 679 "../silver/A.c" 3 4
__builtin_offsetof (
# 679 "../silver/A.c"
enode_f
# 679 "../silver/A.c" 3 4
, 
# 679 "../silver/A.c"
lookup
# 679 "../silver/A.c" 3 4
)
# 679 "../silver/A.c"
; enode_type.members[enode_type.member_count].member_type = A_TYPE_SMETHOD; enode_type.member_count++; enode_type . string_interpolate = & enode_string_interpolate; enode_type.members[enode_type.member_count].name = "string_interpolate"; enode_type.members[enode_type.member_count].args = (args_t) { 2, &A_type, &array_type }; enode_type.members[enode_type.member_count].type = &string_type; enode_type.members[enode_type.member_count].offset = 
# 679 "../silver/A.c" 3 4
__builtin_offsetof (
# 679 "../silver/A.c"
enode_f
# 679 "../silver/A.c" 3 4
, 
# 679 "../silver/A.c"
string_interpolate
# 679 "../silver/A.c" 3 4
)
# 679 "../silver/A.c"
; enode_type.members[enode_type.member_count].member_type = A_TYPE_SMETHOD; enode_type.member_count++; enode_type . exec = & enode_exec; enode_type.members[enode_type.member_count].name = "exec"; enode_type.members[enode_type.member_count].args = (args_t) { 2, &enode_type, &array_type }; enode_type.members[enode_type.member_count].type = &A_type; enode_type.members[enode_type.member_count].offset = 
# 679 "../silver/A.c" 3 4
__builtin_offsetof (
# 679 "../silver/A.c"
enode_f
# 679 "../silver/A.c" 3 4
, 
# 679 "../silver/A.c"
exec
# 679 "../silver/A.c" 3 4
)
# 679 "../silver/A.c"
; enode_type.members[enode_type.member_count].member_type = A_TYPE_IMETHOD; enode_type.member_count++; enode_type . boolean = & enode_boolean;; A_push_type(&enode_type); return (bool)1; } }
# 702 "../silver/A.c"

# 702 "../silver/A.c"
#pragma pack(push, 1)
# 702 "../silver/A.c"
 typedef struct Parser { array tokens; string fname; num cur; } *Parser;
# 702 "../silver/A.c"
#pragma pack(pop)
# 702 "../silver/A.c"
 typedef struct Parser_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(Parser); none (*destructor)(Parser); i32 (*compare)(Parser,Parser); u64 (*hash)(Parser); bool (*boolean)(Parser); ident (*token_at)(Parser, num); ident (*next)(Parser); ident (*pop)(Parser); num (*consume)(Parser); EType (*expect)(Parser, ident, array); EType (*is_alpha_ident)(Parser, ident); ident (*relative)(Parser, num); EType (*is_assign)(Parser, ident); enode (*parse_statements)(Parser); enode (*parse_expression)(Parser); enode (*parse_statement)(Parser); i64 (*parse_numeric)(Parser, ident); EType (*is_var)(Parser, ident); enode (*parse_add)(Parser); enode (*parse_mult)(Parser); enode (*parse_primary)(Parser); } Parser_f, *Parser_t; typedef struct Parser_ctr { Parser (*Parser_default)(struct Parser_f*); Parser (*Parser_of_tokens)(struct Parser_f*, array, string); } Parser_ctr; extern Parser_ctr Parser_new; extern Parser_f Parser_type;

static ident parse_token(char *start, num len, string fname, int line_num) {
    while (start[len - 1] == '\t' || start[len - 1] == ' ')
        len--;
    string all = string_new.string_of_cstr(((string)A_alloc(((struct A_f*)&string_type), 1)), start, len);
    char t = all->chars[0];
    bool is_number = (t == '-' || (t >= '0' && t <= '9'));
    return ident_new.ident_of_token(((ident)A_alloc(((struct A_f*)&ident_type), 1)), all, fname, line_num);
}

static void ws(char **cur) {
    while (**cur == ' ' || **cur == '\t') {
        ++(**cur);
    }
}


static array parse_tokens(string input, string fname) {
    string sp = string_new.string_of_cstr(((string)A_alloc(((struct A_f*)&string_type), 1)), "$,<>()![]/+*:\"\'#", -1);
    char until = 0;
    num len = input->len;
    char* origin = input->chars;
    char* start = 0;
    char* cur = origin - 1;
    int line_num = 1;
    bool new_line = (bool)1;
    bool token_type = (bool)0;
    bool found_null = (bool)0;
    bool multi_comment = (bool)0;
    array tokens = ((array)A_alloc(((struct A_f*)&array_type), 1));

    while (*(++cur)) {
        bool is_ws = (bool)0;
        if (!until) {
            if (new_line)
                new_line = (bool)0;

            if (*cur == ' ' || *cur == '\t' || *cur == '\n' || *cur == '\r') {
                is_ws = (bool)1;
                ws(&cur);
            }
        }
        if (!*cur) break;
        bool add_str = (bool)0;
        char *rel = cur;
        if (*cur == '#') {
            if (cur[1] == '#')
                multi_comment = !multi_comment;
            while (*cur && *cur != '\n')
                cur++;
            found_null = !*cur;
            new_line = (bool)1;
            until = 0;
        }
        if (until) {
            if (*cur == until && *(cur - 1) != '/') {
                add_str = (bool)1;
                until = 0;
                cur++;
                rel = cur;
            }
        }


        if (!until && !multi_comment) {
            char ch[2] = { cur[0], 0 };
            int type = ((string_f*)((A)sp)[-1].type) -> index_of(sp, ch);
            new_line |= *cur == '\n';

            if (start && (is_ws || add_str || (token_type != (type >= 0) || token_type) || new_line)) {
                ident token = parse_token(start, (size_t)(rel - start), fname, line_num);
                ((array_f*)((A)tokens)[-1].type) -> push(tokens, token);
                if (!add_str) {
                    if (*cur == '$' && *(cur + 1) == '(')
                        until = ')';
                    else if (*cur == '"')
                        until = '"';
                    else if (*cur == '\'')
                        until = '\'';
                }
                if (new_line) {
                    start = ((void*)0);
                } else {
                    ws(&cur);
                    start = cur;
                    if (start[0] == ':' && start[1] == ':')
                        cur++;
                    token_type = (type >= 0);
                }
            }
            else if (!start && !new_line) {
                start = cur;
                token_type = (type >= 0);
            }
        }
        if (new_line) {
            until = 0;
            line_num++;
            if (found_null)
                break;
        }
    }
    if (start && (cur - start)) {
        ident token = parse_token(start, cur - start, fname, line_num);
        ((array_f*)((A)tokens)[-1].type) -> push(tokens, token);
    }
    drop(sp);
    return tokens;
}

static ident Parser_of_tokens(Parser a, array tokens, string fname) {
    a->fname = hold(fname);
    a->tokens = hold(tokens);
    return a;
}

static ident Parser_token_at(Parser a, num r) {
    return a->tokens->elements[a->cur + r];
}

static ident Parser_next(Parser a) {
    return ((Parser_f*)((A)a)[-1].type) -> token_at(a, 0);
}

static ident Parser_pop(Parser a) {
    if (a->cur < a->tokens->len)
        a->cur++;
    return a->tokens->elements[a->cur];
}

static num Parser_consume(Parser a) {
    ((Parser_f*)((A)a)[-1].type) -> consume(a);
    return a->cur;
}

static EType Parser_expect(Parser a, ident token, array tokens) {
    return ((array_f*)((A)tokens)[-1].type) -> index_of(tokens, token);
}

static EType Parser_is_alpha_ident(Parser a, ident token) {
    char t = token ? token->value->chars[0] : 0;
    return (
# 844 "../silver/A.c" 3 4
           ((*__ctype_b_loc ())[(int) ((
# 844 "../silver/A.c"
           t
# 844 "../silver/A.c" 3 4
           ))] & (unsigned short int) _ISalpha) 
# 844 "../silver/A.c"
                      && ((array_f*)((A)keywords)[-1].type) -> index_of(keywords, token) == -1) ?
        EType_AlphaIdent : EType_Undefined;
}

static ident Parser_relative(Parser a, num pos) {
    return a->tokens->elements[a->cur + pos];
}

static array assign;

static EType Parser_is_assign(Parser a, ident token) {
    num id = ((array_f*)((A)assign)[-1].type) -> index_of(assign, token);
    return (id >= 0) ? EType_Assign : EType_Undefined;
}

static enode Parser_parse_statements(Parser parser) {
}

static enode Parser_parse_expression(Parser parser) {
}

static enode Parser_parse_statement(Parser parser) {
}

static i64 Parser_parse_numeric(Parser parser, ident token) {
}

static EType Parser_is_var(Parser parser, ident) {
}

static enode Parser_parse_add(Parser parser) {
}

static enode Parser_parse_mult(Parser parser) {
}

static enode Parser_parse_primary(Parser parser) {
}


Parser parser_new(array tokens, string fname) {
    Parser parser = ((Parser)A_alloc(((struct A_f*)&Parser_type), 1));
    parser->tokens = hold(tokens);
    parser->fname = hold(fname);
    return parser;
}

Parser_ctr Parser_new; Parser_f Parser_type; static __attribute__((constructor)) bool global_Parser() { Parser_f* type_ref = &Parser_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_Parser); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(Parser_type) / sizeof(void*)]; Parser_type.parent = & A_type; Parser_type.name = "Parser"; Parser_type.size = sizeof(struct Parser); Parser_type.members = members; Parser_type.traits = 0; Parser_type.arb = &ffi_type_pointer; Parser_type.factory = &Parser_new; Parser_type . token_at = & Parser_token_at; Parser_type.members[Parser_type.member_count].name = "token_at"; Parser_type.members[Parser_type.member_count].args = (args_t) { 2, &Parser_type, &num_type }; Parser_type.members[Parser_type.member_count].type = &ident_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
token_at
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . next = & Parser_next; Parser_type.members[Parser_type.member_count].name = "next"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &ident_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
next
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . pop = & Parser_pop; Parser_type.members[Parser_type.member_count].name = "pop"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &ident_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
pop
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . consume = & Parser_consume; Parser_type.members[Parser_type.member_count].name = "consume"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &num_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
consume
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . expect = & Parser_expect; Parser_type.members[Parser_type.member_count].name = "expect"; Parser_type.members[Parser_type.member_count].args = (args_t) { 3, &Parser_type, &ident_type, &array_type }; Parser_type.members[Parser_type.member_count].type = &EType_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
expect
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . is_alpha_ident = & Parser_is_alpha_ident; Parser_type.members[Parser_type.member_count].name = "is_alpha_ident"; Parser_type.members[Parser_type.member_count].args = (args_t) { 2, &Parser_type, &ident_type }; Parser_type.members[Parser_type.member_count].type = &EType_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
is_alpha_ident
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . relative = & Parser_relative; Parser_type.members[Parser_type.member_count].name = "relative"; Parser_type.members[Parser_type.member_count].args = (args_t) { 2, &Parser_type, &num_type }; Parser_type.members[Parser_type.member_count].type = &ident_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
relative
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . is_assign = & Parser_is_assign; Parser_type.members[Parser_type.member_count].name = "is_assign"; Parser_type.members[Parser_type.member_count].args = (args_t) { 2, &Parser_type, &ident_type }; Parser_type.members[Parser_type.member_count].type = &EType_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
is_assign
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_statements = & Parser_parse_statements; Parser_type.members[Parser_type.member_count].name = "parse_statements"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &enode_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
parse_statements
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_expression = & Parser_parse_expression; Parser_type.members[Parser_type.member_count].name = "parse_expression"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &enode_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
parse_expression
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_statement = & Parser_parse_statement; Parser_type.members[Parser_type.member_count].name = "parse_statement"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &enode_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
parse_statement
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_numeric = & Parser_parse_numeric; Parser_type.members[Parser_type.member_count].name = "parse_numeric"; Parser_type.members[Parser_type.member_count].args = (args_t) { 2, &Parser_type, &ident_type }; Parser_type.members[Parser_type.member_count].type = &i64_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
parse_numeric
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . is_var = & Parser_is_var; Parser_type.members[Parser_type.member_count].name = "is_var"; Parser_type.members[Parser_type.member_count].args = (args_t) { 2, &Parser_type, &ident_type }; Parser_type.members[Parser_type.member_count].type = &EType_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
is_var
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_add = & Parser_parse_add; Parser_type.members[Parser_type.member_count].name = "parse_add"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &enode_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
parse_add
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_mult = & Parser_parse_mult; Parser_type.members[Parser_type.member_count].name = "parse_mult"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &enode_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
parse_mult
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_primary = & Parser_parse_primary; Parser_type.members[Parser_type.member_count].name = "parse_primary"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &enode_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_f
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
parse_primary
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_new . Parser_of_tokens = & Parser_of_tokens; 
# 891 "../silver/A.c" 3 4
((void) sizeof ((
# 891 "../silver/A.c"
"Parser" == "Parser"
# 891 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 891 "../silver/A.c"
"Parser" == "Parser"
# 891 "../silver/A.c" 3 4
) ; else __assert_fail (
# 891 "../silver/A.c"
"\"Parser\" == \"Parser\""
# 891 "../silver/A.c" 3 4
, "../silver/A.c", 891, __extension__ __PRETTY_FUNCTION__); }))
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].name = "of_tokens"; Parser_type.members[Parser_type.member_count].args = (args_t) { 3, &Parser_type, &array_type, &string_type }; Parser_type.members[Parser_type.member_count].type = &Parser_type; Parser_type.members[Parser_type.member_count].offset = 
# 891 "../silver/A.c" 3 4
__builtin_offsetof (
# 891 "../silver/A.c"
Parser_ctr
# 891 "../silver/A.c" 3 4
, 
# 891 "../silver/A.c"
Parser_of_tokens
# 891 "../silver/A.c" 3 4
)
# 891 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_CONSTRUCT; Parser_type.member_count++;; A_push_type(&Parser_type); return (bool)1; } }
# 903 "../silver/A.c"

# 903 "../silver/A.c"
#pragma pack(push, 1)
# 903 "../silver/A.c"
 typedef struct module_t { array tokens; string module_name; array imports; handle app; array implementation; } *emodule;
# 903 "../silver/A.c"
#pragma pack(pop)
# 903 "../silver/A.c"
 typedef struct emodule_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(emodule); none (*destructor)(emodule); i32 (*compare)(emodule,emodule); u64 (*hash)(emodule); bool (*boolean)(emodule); none (*graph)(emodule); none (*c99)(emodule); none (*run)(emodule); } emodule_f, *emodule_t; typedef struct emodule_ctr { emodule (*emodule_default)(struct emodule_f*); emodule (*emodule_of_source)(struct emodule_f*, string); } emodule_ctr; extern emodule_ctr emodule_new; extern emodule_f emodule_type;




typedef enum EMembership { EMembership_normal, EMembership_internal, } EMembership; typedef struct EMembership_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(EMembership); none (*destructor)(EMembership); i32 (*compare)(EMembership,EMembership); u64 (*hash)(EMembership); bool (*boolean)(EMembership); } EMembership_f, *EMembership_t; extern EMembership_f EMembership_type;
EMembership_f EMembership_type; static __attribute__((constructor)) bool global_EMembership() { EMembership_f* type_ref = &EMembership_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_EMembership); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(EMembership_type) / sizeof(void*)]; EMembership_type.parent = & A_type; EMembership_type.name = "EMembership"; EMembership_type.size = sizeof(enum EMembership); EMembership_type.members = members; EMembership_type.traits = (1 << 1); EMembership_type.arb = &ffi_type_sint32; EMembership_type.members[EMembership_type.member_count].name = "normal"; EMembership_type.members[EMembership_type.member_count].offset = EMembership_normal; EMembership_type.members[EMembership_type.member_count].type = &i32_type; EMembership_type.members[EMembership_type.member_count].member_type = A_TYPE_ENUMV; EMembership_type.member_count++; EMembership_type.members[EMembership_type.member_count].name = "internal"; EMembership_type.members[EMembership_type.member_count].offset = EMembership_internal; EMembership_type.members[EMembership_type.member_count].type = &i32_type; EMembership_type.members[EMembership_type.member_count].member_type = A_TYPE_ENUMV; EMembership_type.member_count++;; A_push_type(&EMembership_type); return (bool)1; } }
# 925 "../silver/A.c"
typedef enum EModel { EModel_allocated, EModel_boolean_32, EModel_unsigned_8, EModel_unsigned_16, EModel_unsigned_32, EModel_unsigned_64, EModel_signed_8, EModel_signed_16, EModel_signed_32, EModel_signed_64, EModel_real_32, EModel_real_64, EModel_real_128, } EModel; typedef struct EModel_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(EModel); none (*destructor)(EModel); i32 (*compare)(EModel,EModel); u64 (*hash)(EModel); bool (*boolean)(EModel); } EModel_f, *EModel_t; extern EModel_f EModel_type;
EModel_f EModel_type; static __attribute__((constructor)) bool global_EModel() { EModel_f* type_ref = &EModel_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_EModel); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(EModel_type) / sizeof(void*)]; EModel_type.parent = & A_type; EModel_type.name = "EModel"; EModel_type.size = sizeof(enum EModel); EModel_type.members = members; EModel_type.traits = (1 << 1); EModel_type.arb = &ffi_type_sint32; EModel_type.members[EModel_type.member_count].name = "allocated"; EModel_type.members[EModel_type.member_count].offset = EModel_allocated; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++; EModel_type.members[EModel_type.member_count].name = "boolean_32"; EModel_type.members[EModel_type.member_count].offset = EModel_boolean_32; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++; EModel_type.members[EModel_type.member_count].name = "unsigned_8"; EModel_type.members[EModel_type.member_count].offset = EModel_unsigned_8; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++; EModel_type.members[EModel_type.member_count].name = "unsigned_16"; EModel_type.members[EModel_type.member_count].offset = EModel_unsigned_16; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++; EModel_type.members[EModel_type.member_count].name = "unsigned_32"; EModel_type.members[EModel_type.member_count].offset = EModel_unsigned_32; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++; EModel_type.members[EModel_type.member_count].name = "unsigned_64"; EModel_type.members[EModel_type.member_count].offset = EModel_unsigned_64; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++; EModel_type.members[EModel_type.member_count].name = "signed_8"; EModel_type.members[EModel_type.member_count].offset = EModel_signed_8; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++; EModel_type.members[EModel_type.member_count].name = "signed_16"; EModel_type.members[EModel_type.member_count].offset = EModel_signed_16; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++; EModel_type.members[EModel_type.member_count].name = "signed_32"; EModel_type.members[EModel_type.member_count].offset = EModel_signed_32; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++; EModel_type.members[EModel_type.member_count].name = "signed_64"; EModel_type.members[EModel_type.member_count].offset = EModel_signed_64; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++; EModel_type.members[EModel_type.member_count].name = "real_32"; EModel_type.members[EModel_type.member_count].offset = EModel_real_32; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++; EModel_type.members[EModel_type.member_count].name = "real_64"; EModel_type.members[EModel_type.member_count].offset = EModel_real_64; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++; EModel_type.members[EModel_type.member_count].name = "real_128"; EModel_type.members[EModel_type.member_count].offset = EModel_real_128; EModel_type.members[EModel_type.member_count].type = &i32_type; EModel_type.members[EModel_type.member_count].member_type = A_TYPE_ENUMV; EModel_type.member_count++;; A_push_type(&EModel_type); return (bool)1; } }
# 935 "../silver/A.c"

# 935 "../silver/A.c"
#pragma pack(push, 1)
# 935 "../silver/A.c"
 typedef struct emodule_member { string name; string keyword; array template_args; EMembership membership; emodule module; } *emodule_member;
# 935 "../silver/A.c"
#pragma pack(pop)
# 935 "../silver/A.c"
 typedef struct emodule_member_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(emodule_member); none (*destructor)(emodule_member); i32 (*compare)(emodule_member,emodule_member); u64 (*hash)(emodule_member); bool (*boolean)(emodule_member); } emodule_member_f, *emodule_member_t; typedef struct emodule_member_ctr { emodule_member (*emodule_member_default)(struct emodule_member_f*); emodule_member (*emodule_member_with_parser)(struct emodule_member_f*, Parser, EMembership, array, string); } emodule_member_ctr; extern emodule_member_ctr emodule_member_new; extern emodule_member_f emodule_member_type;

emodule_member emodule_member_with_parser(emodule_member import, Parser parser, EMembership membership, array t_args, string keyword) {
    
# 938 "../silver/A.c" 3 4
   ((void) sizeof ((
# 938 "../silver/A.c"
   (bool)0
# 938 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 938 "../silver/A.c"
   (bool)0
# 938 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 938 "../silver/A.c"
   "false"
# 938 "../silver/A.c" 3 4
   , "../silver/A.c", 938, __extension__ __PRETTY_FUNCTION__); }))
# 938 "../silver/A.c"
                ;
    return ((void*)0);
}





typedef emodule_member silver_t;
# 955 "../silver/A.c"

# 955 "../silver/A.c"
#pragma pack(push, 1)
# 955 "../silver/A.c"
 typedef struct eclass { string name; string keyword; array template_args; EMembership membership; emodule module; EModel model; string from; array members; array friends; bool is_translated; } *eclass;
# 955 "../silver/A.c"
#pragma pack(pop)
# 955 "../silver/A.c"
 typedef struct eclass_f { struct emodule_member_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(eclass); none (*destructor)(eclass); i32 (*compare)(eclass,eclass); u64 (*hash)(eclass); bool (*boolean)(eclass); } eclass_f, *eclass_t; typedef struct eclass_ctr { emodule_member (*emodule_member_with_parser)(struct emodule_member_f*, Parser, EMembership, array, string); } eclass_ctr; extern eclass_ctr eclass_new; extern eclass_f eclass_type;
# 967 "../silver/A.c"

# 967 "../silver/A.c"
#pragma pack(push, 1)
# 967 "../silver/A.c"
 typedef struct eimport { string name; string keyword; array template_args; EMembership membership; emodule module; string import_name; string source; string shell; array links; array includes; array defines; string isolate_namespace; string module_path; } *eimport;
# 967 "../silver/A.c"
#pragma pack(pop)
# 967 "../silver/A.c"
 typedef struct eimport_f { struct emodule_member_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; struct A_ctr* factory; void* arb; none (*init)(eimport); none (*destructor)(eimport); i32 (*compare)(eimport,eimport); u64 (*hash)(eimport); bool (*boolean)(eimport); } eimport_f, *eimport_t; typedef struct eimport_ctr { emodule_member (*emodule_member_with_parser)(struct emodule_member_f*, Parser, EMembership, array, string); } eimport_ctr; extern eimport_ctr eimport_new; extern eimport_f eimport_type;

eimport eimport_with_parser(eimport import, Parser parser, EMembership membership, array t_args, string keyword) {
# 1051 "../silver/A.c"
}

eimport_ctr eimport_new; eimport_f eimport_type; static __attribute__((constructor)) bool global_eimport() { eimport_f* type_ref = &eimport_type; emodule_member_f* base_ref = &emodule_member_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_eimport); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(emodule_member_f)); static member_t members[sizeof(eimport_type) / sizeof(void*)]; eimport_type.parent = & emodule_member_type; eimport_type.name = "eimport"; eimport_type.size = sizeof(struct eimport); eimport_type.members = members; eimport_type.traits = 0; eimport_type.arb = &ffi_type_pointer; eimport_type.factory = &eimport_new; emodule_member_new . emodule_member_with_parser = & emodule_member_with_parser; 
# 1053 "../silver/A.c" 3 4
((void) sizeof ((
# 1053 "../silver/A.c"
"emodule_member" == "emodule_member"
# 1053 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 1053 "../silver/A.c"
"emodule_member" == "emodule_member"
# 1053 "../silver/A.c" 3 4
) ; else __assert_fail (
# 1053 "../silver/A.c"
"\"emodule_member\" == \"emodule_member\""
# 1053 "../silver/A.c" 3 4
, "../silver/A.c", 1053, __extension__ __PRETTY_FUNCTION__); }))
# 1053 "../silver/A.c"
; emodule_member_type.members[emodule_member_type.member_count].name = "with_parser"; emodule_member_type.members[emodule_member_type.member_count].args = (args_t) { 5, &emodule_member_type, &Parser_type, &EMembership_type, &array_type, &string_type }; emodule_member_type.members[emodule_member_type.member_count].type = &emodule_member_type; emodule_member_type.members[emodule_member_type.member_count].offset = 
# 1053 "../silver/A.c" 3 4
__builtin_offsetof (
# 1053 "../silver/A.c"
emodule_member_ctr
# 1053 "../silver/A.c" 3 4
, 
# 1053 "../silver/A.c"
emodule_member_with_parser
# 1053 "../silver/A.c" 3 4
)
# 1053 "../silver/A.c"
; emodule_member_type.members[emodule_member_type.member_count].member_type = A_TYPE_CONSTRUCT; emodule_member_type.member_count++; eimport_new . with_parser = (__typeof__(eimport_new.with_parser))& eimport_with_parser;; A_push_type(&eimport_type); return (bool)1; } }



void assertion(Parser parser, bool is_true, cstr message, ...) {
    if (!is_true) {
        char buffer[1024];
        va_list args;
        
# 1061 "../silver/A.c" 3 4
       __builtin_va_start(
# 1061 "../silver/A.c"
       args
# 1061 "../silver/A.c" 3 4
       ,
# 1061 "../silver/A.c"
       message
# 1061 "../silver/A.c" 3 4
       )
# 1061 "../silver/A.c"
                              ;
        vsprintf(buffer, message, args);
        
# 1063 "../silver/A.c" 3 4
       __builtin_va_end(
# 1063 "../silver/A.c"
       args
# 1063 "../silver/A.c" 3 4
       )
# 1063 "../silver/A.c"
                   ;
        printf("%s\n", buffer);
    }
}



eclass eclass_with_parser(
        eclass cl, Parser parser, EMembership membership, array template_args, string keyword) {
    cl->membership = membership;
    cl->template_args = hold(template_args);
    cl->keyword = hold(keyword);


    ident ikeyword = ident_new.ident_of_token(((ident)A_alloc(((struct A_f*)&ident_type), 1)), keyword, ((void*)0), 0);
    ident inext = ((Parser_f*)((A)parser)[-1].type) -> pop(parser);
    bool cmp = ((A_f*)((A)inext)[-1].type) -> compare(inext, ikeyword);
    assertion(parser, cmp == 0, "expected %s", keyword->chars);
# 1167 "../silver/A.c"
    return cl;
}

void push_implementation(emodule m, Parser parser, ident keyword, ident name, emodule_member mm) {
    for (num i = 0; i < m->implementation->len; i++) {
        emodule_member mm = m->implementation->elements[i];
        if (strcmp(mm->name->chars, name->value->chars) == 0) {
            assertion(parser, (bool)0, "duplicate identifier for %s: %s", keyword->value->chars, name->value->chars);
        }
    }
    ((array_f*)((A)m->implementation)[-1].type) -> push(m->implementation, mm);
    mm->module = (emodule)hold(m);
    if (strcmp(name->value->chars, "app") == 0)
        m->app = (eclass)mm;
};




emodule emodule_of_source(emodule m, string fname) {
    string contents = string_new.string_of_file(((string)A_alloc(((struct A_f*)&string_type), 1)), fname->chars);
    m->module_name = hold(fname);
    m->tokens = parse_tokens(contents, fname);
    drop(contents);
    Parser parser = Parser_new.Parser_of_tokens(((Parser)A_alloc(((struct A_f*)&Parser_type), 1)), m->tokens, fname);

    int imports = 0;
    int includes = 0;
    bool inlay = (bool)0;
    array templ_args;

    for (;;) {

        ident token = ((Parser_f*)((A)parser)[-1].type) -> next(parser);
        if (!token)
            break;
        bool intern = (bool)0;
        if (strcmp(token->value->chars, "intern") == 0) {
            ((Parser_f*)((A)parser)[-1].type) -> consume(parser);
            token = ((Parser_f*)((A)parser)[-1].type) -> pop(parser);
            intern = (bool)1;
        }


        if (strcmp(token->value->chars, "class") != 0 && templ_args) {
            assertion(parser, (bool)0, "expected class after template definition");
        }

        if (strcmp(token->value->chars, "import") == 0) {
            assertion(parser, !intern, "intern keyword not applicable to import");
            eimport import(parser);
            imports++;
            string import_str = "import{0}";
            string import_id = import_str->format({ imports });
            push_implementation(m, parser, token, import_id, import);
            m->imports += import;


            if (import->name && !import->source) {
                string loc = "{1}{0}.si";
                vector<string> attempt = {"", "spec/"};
                bool exists = (bool)0;
                for (string pre: attempt) {
                    path si_path = loc->format({ import->name, pre });

                    if (!si_path->exists())
                        continue;
                    import->module_path = si_path;
                    console.log("module {0}", { si_path });
                    import->module = parse(si_path);
                    exists = (bool)1;
                    break;
                }
                assertion(parser, exists, "path does not exist for silver module: {0}", { import->name });
            }
        }
# 1269 "../silver/A.c"
    }

    return m;
}

void emodule_graph(emodule m) {
}

void emodule_c99(emodule m) {
    int test = 0;
    test++;
}

void emodule_run(emodule m) {
}

emodule_ctr emodule_new; emodule_f emodule_type; static __attribute__((constructor)) bool global_emodule() { emodule_f* type_ref = &emodule_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_emodule); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(emodule_type) / sizeof(void*)]; emodule_type.parent = & A_type; emodule_type.name = "emodule"; emodule_type.size = sizeof(struct emodule); emodule_type.members = members; emodule_type.traits = 0; emodule_type.arb = &ffi_type_pointer; emodule_type.factory = &emodule_new; emodule_new . emodule_of_source = & emodule_of_source; 
# 1285 "../silver/A.c" 3 4
((void) sizeof ((
# 1285 "../silver/A.c"
"emodule" == "emodule"
# 1285 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 1285 "../silver/A.c"
"emodule" == "emodule"
# 1285 "../silver/A.c" 3 4
) ; else __assert_fail (
# 1285 "../silver/A.c"
"\"emodule\" == \"emodule\""
# 1285 "../silver/A.c" 3 4
, "../silver/A.c", 1285, __extension__ __PRETTY_FUNCTION__); }))
# 1285 "../silver/A.c"
; emodule_type.members[emodule_type.member_count].name = "of_source"; emodule_type.members[emodule_type.member_count].args = (args_t) { 2, &emodule_type, &string_type }; emodule_type.members[emodule_type.member_count].type = &emodule_type; emodule_type.members[emodule_type.member_count].offset = 
# 1285 "../silver/A.c" 3 4
__builtin_offsetof (
# 1285 "../silver/A.c"
emodule_ctr
# 1285 "../silver/A.c" 3 4
, 
# 1285 "../silver/A.c"
emodule_of_source
# 1285 "../silver/A.c" 3 4
)
# 1285 "../silver/A.c"
; emodule_type.members[emodule_type.member_count].member_type = A_TYPE_CONSTRUCT; emodule_type.member_count++; emodule_type . graph = & emodule_graph; emodule_type.members[emodule_type.member_count].name = "graph"; emodule_type.members[emodule_type.member_count].args = (args_t) { 1, &emodule_type }; emodule_type.members[emodule_type.member_count].type = &none_type; emodule_type.members[emodule_type.member_count].offset = 
# 1285 "../silver/A.c" 3 4
__builtin_offsetof (
# 1285 "../silver/A.c"
emodule_f
# 1285 "../silver/A.c" 3 4
, 
# 1285 "../silver/A.c"
graph
# 1285 "../silver/A.c" 3 4
)
# 1285 "../silver/A.c"
; emodule_type.members[emodule_type.member_count].member_type = A_TYPE_IMETHOD; emodule_type.member_count++; emodule_type . c99 = & emodule_c99; emodule_type.members[emodule_type.member_count].name = "c99"; emodule_type.members[emodule_type.member_count].args = (args_t) { 1, &emodule_type }; emodule_type.members[emodule_type.member_count].type = &none_type; emodule_type.members[emodule_type.member_count].offset = 
# 1285 "../silver/A.c" 3 4
__builtin_offsetof (
# 1285 "../silver/A.c"
emodule_f
# 1285 "../silver/A.c" 3 4
, 
# 1285 "../silver/A.c"
c99
# 1285 "../silver/A.c" 3 4
)
# 1285 "../silver/A.c"
; emodule_type.members[emodule_type.member_count].member_type = A_TYPE_IMETHOD; emodule_type.member_count++; emodule_type . run = & emodule_run; emodule_type.members[emodule_type.member_count].name = "run"; emodule_type.members[emodule_type.member_count].args = (args_t) { 1, &emodule_type }; emodule_type.members[emodule_type.member_count].type = &none_type; emodule_type.members[emodule_type.member_count].offset = 
# 1285 "../silver/A.c" 3 4
__builtin_offsetof (
# 1285 "../silver/A.c"
emodule_f
# 1285 "../silver/A.c" 3 4
, 
# 1285 "../silver/A.c"
run
# 1285 "../silver/A.c" 3 4
)
# 1285 "../silver/A.c"
; emodule_type.members[emodule_type.member_count].member_type = A_TYPE_IMETHOD; emodule_type.member_count++;; A_push_type(&emodule_type); return (bool)1; } }

int main(int argc, char **argv) {
    A_finish_types();


    keywords = ((array)A_alloc(((struct A_f*)&array_type), 1));
    ((array_f*)((A)keywords)[-1].type) -> push_symbols(keywords, "class", "proto", "struct", "import", "return", "asm", "if", "switch", "while", "for", "do", ((void*)0))


                                              ;

    assign = ((array)A_alloc(((struct A_f*)&array_type), 1));
    ((array_f*)((A)assign)[-1].type) -> push_symbols(assign, ":", "+=", "-=", "*=", "/=", "|=", "&=", "^=", ">>=", "<<=", "%=", ((void*)0))

                                             ;

    chdir("spec");
    string fname = string_new.string_of_cstr(((string)A_alloc(((struct A_f*)&string_type), 1)), "basic.si", -1);
    emodule m = emodule_new.emodule_of_source(((emodule)A_alloc(((struct A_f*)&emodule_type), 1)), fname);
    ((emodule_f*)((A)m)[-1].type) -> graph(m);
    ((emodule_f*)((A)m)[-1].type) -> c99(m);

    return 0;
}
