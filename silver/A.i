# 0 "../silver/A.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "../silver/A.c"
# 1 "../silver/A.h" 1



# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 392 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4
# 486 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 559 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 560 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 561 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 487 "/usr/include/features.h" 2 3 4
# 510 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 511 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4
# 52 "/usr/include/stdio.h" 3 4
typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;
# 77 "/usr/include/stdio.h" 3 4
typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4
# 143 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 178 "/usr/include/stdio.h" 3 4
extern int fclose (FILE *__stream);
# 188 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 205 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char[20]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char __s[20]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 222 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (__builtin_free, 1)));






extern int fflush (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 258 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 293 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 308 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 328 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 403 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));





# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 119 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 431 "/usr/include/stdio.h" 2 3 4



extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 459 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 538 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 549 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 565 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
# 632 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 702 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 736 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 760 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 786 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 823 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream);





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (pclose, 1))) ;






extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1)));
# 867 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 885 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 902 "/usr/include/stdio.h" 3 4

# 5 "../silver/A.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
typedef int wchar_t;
# 33 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 386 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;
# 59 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 144 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 102 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 227 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 396 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));


extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)))
    __attribute__ ((__malloc__ (__builtin_free, 1)));


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__ (reallocarray, 1)));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 575 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
     __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 654 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 682 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 738 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 791 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;
# 808 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 828 "/usr/include/stdlib.h" 3 4
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 848 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 880 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1, 3)))
  __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 967 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 1013 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1023 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1024 "/usr/include/stdlib.h" 2 3 4
# 1035 "/usr/include/stdlib.h" 3 4

# 6 "../silver/A.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 107 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 173 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 246 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 293 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 323 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 350 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 407 "/usr/include/string.h" 3 4
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 432 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)))
    __attribute__ ((__access__ (__write_only__, 2, 3)));
# 458 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));
# 489 "/usr/include/string.h" 3 4
extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 539 "/usr/include/string.h" 3 4

# 7 "../silver/A.h" 2
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4



extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



# 8 "../silver/A.h" 2
# 1 "/usr/include/x86_64-linux-gnu/ffi.h" 1 3 4
# 59 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/ffitarget.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/ffitarget.h" 3 4
typedef unsigned long ffi_arg;
typedef signed long ffi_sarg;



typedef enum ffi_abi {
# 93 "/usr/include/x86_64-linux-gnu/ffitarget.h" 3 4
  FFI_FIRST_ABI = 1,
  FFI_UNIX64,
  FFI_WIN64,
  FFI_EFI64 = FFI_WIN64,
  FFI_GNUW64,
  FFI_LAST_ABI,
  FFI_DEFAULT_ABI = FFI_UNIX64
# 124 "/usr/include/x86_64-linux-gnu/ffitarget.h" 3 4
} ffi_abi;
# 151 "/usr/include/x86_64-linux-gnu/ffitarget.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/cet.h" 1 3 4
# 152 "/usr/include/x86_64-linux-gnu/ffitarget.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/ffi.h" 2 3 4







# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
} max_align_t;
# 68 "/usr/include/x86_64-linux-gnu/ffi.h" 2 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 1 3 4
# 203 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 195 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 81 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 2 3 4
# 82 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 196 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 200 "/usr/include/limits.h" 2 3 4
# 204 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/11/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 2 3 4
# 69 "/usr/include/x86_64-linux-gnu/ffi.h" 2 3 4
# 104 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
typedef struct _ffi_type
{
  size_t size;
  unsigned short alignment;
  unsigned short type;
  struct _ffi_type **elements;
} ffi_type;
# 188 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
extern ffi_type ffi_type_void;
extern ffi_type ffi_type_uint8;
extern ffi_type ffi_type_sint8;
extern ffi_type ffi_type_uint16;
extern ffi_type ffi_type_sint16;
extern ffi_type ffi_type_uint32;
extern ffi_type ffi_type_sint32;
extern ffi_type ffi_type_uint64;
extern ffi_type ffi_type_sint64;
extern ffi_type ffi_type_float;
extern ffi_type ffi_type_double;
extern ffi_type ffi_type_pointer;


extern ffi_type ffi_type_longdouble;





extern ffi_type ffi_type_complex_float;
extern ffi_type ffi_type_complex_double;

extern ffi_type ffi_type_complex_longdouble;






typedef enum {
  FFI_OK = 0,
  FFI_BAD_TYPEDEF,
  FFI_BAD_ABI,
  FFI_BAD_ARGTYPE
} ffi_status;

typedef struct {
  ffi_abi abi;
  unsigned nargs;
  ffi_type **arg_types;
  ffi_type *rtype;
  unsigned bytes;
  unsigned flags;



} ffi_cif;
# 251 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
typedef union {
  ffi_sarg sint;
  ffi_arg uint;
  float flt;
  char data[8];
  void* ptr;
} ffi_raw;
# 270 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
typedef ffi_raw ffi_java_raw;




void ffi_raw_call (ffi_cif *cif,
     void (*fn)(void),
     void *rvalue,
     ffi_raw *avalue);

 void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);
 void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);
 size_t ffi_raw_size (ffi_cif *cif);







void ffi_java_raw_call (ffi_cif *cif,
   void (*fn)(void),
   void *rvalue,
   ffi_java_raw *avalue) __attribute__((deprecated));



void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw) __attribute__((deprecated));

void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args) __attribute__((deprecated));

size_t ffi_java_raw_size (ffi_cif *cif) __attribute__((deprecated));
# 310 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
typedef struct {




  union {
    char tramp[32];
    void *ftramp;
  };

  ffi_cif *cif;
  void (*fun)(ffi_cif*,void*,void**,void*);
  void *user_data;
} ffi_closure

    __attribute__((aligned (8)))

    ;







 void *ffi_closure_alloc (size_t size, void **code);
 void ffi_closure_free (void *);
# 346 "/usr/include/x86_64-linux-gnu/ffi.h" 3 4
 ffi_status
ffi_prep_closure (ffi_closure*,
    ffi_cif *,
    void (*fun)(ffi_cif*,void*,void**,void*),
    void *user_data)

  __attribute__((deprecated ("use ffi_prep_closure_loc instead")))



  ;

 ffi_status
ffi_prep_closure_loc (ffi_closure*,
        ffi_cif *,
        void (*fun)(ffi_cif*,void*,void**,void*),
        void *user_data,
        void*codeloc);




typedef struct {




  char tramp[32];

  ffi_cif *cif;







  void (*translate_args)(ffi_cif*,void*,void**,void*);
  void *this_closure;



  void (*fun)(ffi_cif*,void*,ffi_raw*,void*);
  void *user_data;

} ffi_raw_closure;

typedef struct {




  char tramp[32];


  ffi_cif *cif;







  void (*translate_args)(ffi_cif*,void*,void**,void*);
  void *this_closure;



  void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*);
  void *user_data;

} ffi_java_raw_closure;

 ffi_status
ffi_prep_raw_closure (ffi_raw_closure*,
        ffi_cif *cif,
        void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
        void *user_data);

 ffi_status
ffi_prep_raw_closure_loc (ffi_raw_closure*,
     ffi_cif *cif,
     void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
     void *user_data,
     void *codeloc);


 ffi_status
ffi_prep_java_raw_closure (ffi_java_raw_closure*,
             ffi_cif *cif,
             void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
             void *user_data) __attribute__((deprecated));

 ffi_status
ffi_prep_java_raw_closure_loc (ffi_java_raw_closure*,
          ffi_cif *cif,
          void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
          void *user_data,
          void *codeloc) __attribute__((deprecated));






typedef struct {
  void *tramp;
  ffi_cif *cif;
  void (*fun)(ffi_cif*,void*,void**,void*);
} ffi_go_closure;

 ffi_status ffi_prep_go_closure (ffi_go_closure*, ffi_cif *,
    void (*fun)(ffi_cif*,void*,void**,void*));

 void ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
    void **avalue, void *closure);






ffi_status ffi_prep_cif(ffi_cif *cif,
   ffi_abi abi,
   unsigned int nargs,
   ffi_type *rtype,
   ffi_type **atypes);


ffi_status ffi_prep_cif_var(ffi_cif *cif,
       ffi_abi abi,
       unsigned int nfixedargs,
       unsigned int ntotalargs,
       ffi_type *rtype,
       ffi_type **atypes);


void ffi_call(ffi_cif *cif,
       void (*fn)(void),
       void *rvalue,
       void **avalue);


ffi_status ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type,
       size_t *offsets);
# 9 "../silver/A.h" 2






# 14 "../silver/A.h"
typedef void none;
typedef signed char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef unsigned long long num;
typedef unsigned int bool;
typedef float f32;
typedef double f64;
typedef long double f128;
typedef double real;

typedef struct A_f* AType;

enum A_TYPE {
    A_TYPE_NONE = 0,
    A_TYPE_PROP = 1,
    A_TYPE_IMETHOD = 2,
    A_TYPE_SMETHOD = 4,
    A_TYPE_CONSTRUCT = 8,
    A_TYPE_ENUMV = 16
};
# 167 "../silver/A.h"
typedef bool(*global_init_fn)();






typedef struct A_f* A_t;

typedef struct args_t {
    num count;
    A_t arg_0, arg_1, arg_2, arg_3,
                    arg_4, arg_5, arg_6, arg_7;
} args_t;

typedef struct method_t {
    void* address;
    void* ffi_cif;
    void* ffi_args;
} method_t;

typedef struct prop_t {
    void* address;
} prop_t;



typedef struct member_t {
    char* name;
    A_t type;
    num offset;
    enum A_TYPE member_type;
    args_t args;
    union {
        method_t* method;
        prop_t* prop;
    };
} member_t;
# 323 "../silver/A.h"
void A_lazy_init(global_init_fn fn);
# 376 "../silver/A.h"

# 376 "../silver/A.h"
#pragma pack(push, 1)
# 376 "../silver/A.h"
 typedef struct A { A_t type; num refs; struct A* data; num alloc; num count; struct A* origin; struct A* object; } *A;
# 376 "../silver/A.h"
#pragma pack(pop)
# 376 "../silver/A.h"
 typedef struct A_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } A_f; typedef struct A_ctr { A (*A_default)(struct A_f*, num); } A_ctr; extern A_f A_type;




typedef struct i8_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } i8_f; extern i8_f i8_type;
typedef struct i16_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } i16_f; extern i16_f i16_type;
typedef struct i32_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } i32_f; extern i32_f i32_type;
typedef struct i64_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } i64_f; extern i64_f i64_type;
typedef struct u8_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } u8_f; extern u8_f u8_type;
typedef struct u16_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } u16_f; extern u16_f u16_type;
typedef struct u32_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } u32_f; extern u32_f u32_type;
typedef struct u64_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } u64_f; extern u64_f u64_type;
typedef struct f32_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } f32_f; extern f32_f f32_type;
typedef struct f64_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } f64_f; extern f64_f f64_type;
typedef struct f128_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } f128_f; extern f128_f f128_type;
typedef struct cstr_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } cstr_f; extern cstr_f cstr_type;
typedef struct bool_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } bool_f; extern bool_f bool_type;
typedef struct none_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } none_f; extern none_f none_type;
typedef struct num_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } num_f; extern num_f num_type;


typedef struct AType_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(A); none (*destructor)(A); i32 (*compare)(A,A); u64 (*hash)(A); bool (*boolean)(A); } AType_f; extern AType_f AType_type;







# 405 "../silver/A.h"
#pragma pack(push, 1)
# 405 "../silver/A.h"
 typedef struct item { struct item* next; struct item* prev; A element; } *item;
# 405 "../silver/A.h"
#pragma pack(pop)
# 405 "../silver/A.h"
 typedef struct item_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(item); none (*destructor)(item); i32 (*compare)(item,item); u64 (*hash)(item); bool (*boolean)(item); } item_f; typedef struct item_ctr { item (*item_default)(struct item_f*, num); } item_ctr; extern item_ctr item_new; extern item_f item_type;








# 413 "../silver/A.h"
#pragma pack(push, 1)
# 413 "../silver/A.h"
 typedef struct collection { } *collection;
# 413 "../silver/A.h"
#pragma pack(pop)
# 413 "../silver/A.h"
 typedef struct collection_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(collection); none (*destructor)(collection); i32 (*compare)(collection,collection); u64 (*hash)(collection); bool (*boolean)(collection); } collection_f; extern collection_f collection_type;
# 426 "../silver/A.h"

# 426 "../silver/A.h"
#pragma pack(push, 1)
# 426 "../silver/A.h"
 typedef struct list { item first; item last; i64 count; i32 public_integer; } *list;
# 426 "../silver/A.h"
#pragma pack(pop)
# 426 "../silver/A.h"
 typedef struct list_f { struct collection_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(list); none (*destructor)(list); i32 (*compare)(list,list); u64 (*hash)(list); bool (*boolean)(list); A (*pop)(list); none (*push)(list, A); A (*get)(list, i32); num (*count)(list); } list_f; typedef struct list_ctr { } list_ctr; extern list_ctr list_new; extern list_f list_type;

typedef char* cstr;
# 445 "../silver/A.h"

# 445 "../silver/A.h"
#pragma pack(push, 1)
# 445 "../silver/A.h"
 typedef struct array { A* elements; i32 alloc; i32 len; } *array;
# 445 "../silver/A.h"
#pragma pack(pop)
# 445 "../silver/A.h"
 typedef struct array_f { struct collection_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(array); none (*destructor)(array); i32 (*compare)(array,array); u64 (*hash)(array); bool (*boolean)(array); array (*pop)(array); none (*push)(array,A); A (*get)(array, i32); array (*count)(array); num (*index_of)(array, A); none (*push_symbols)(array, cstr, ...); none (*push_objects)(array, A, ...); } array_f; typedef struct array_ctr { array (*array_with_cstr)(struct array_f*, num, cstr); } array_ctr; extern array_ctr array_new; extern array_f array_type;
# 454 "../silver/A.h"

# 454 "../silver/A.h"
#pragma pack(push, 1)
# 454 "../silver/A.h"
 typedef struct string { char* chars; num alloc; num len; u64 h; } *string;
# 454 "../silver/A.h"
#pragma pack(pop)
# 454 "../silver/A.h"
 typedef struct string_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(string); none (*destructor)(string); i32 (*compare)(string,string); u64 (*hash)(string); bool (*boolean)(string); array (*split)(string, A); } string_f; typedef struct string_ctr { string (*string_default)(struct string_f*, num); } string_ctr; extern string_ctr string_new; extern string_f string_type;
# 465 "../silver/A.h"

# 465 "../silver/A.h"
#pragma pack(push, 1)
# 465 "../silver/A.h"
 typedef struct vector { i32 alloc; i32 len; } *vector;
# 465 "../silver/A.h"
#pragma pack(pop)
# 465 "../silver/A.h"
 typedef struct vector_f { struct collection_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(vector); none (*destructor)(vector); i32 (*compare)(vector,vector); u64 (*hash)(vector); bool (*boolean)(vector); A (*pop)(vector); void (*push)(vector, A); A (*get)(vector, i32); num (*count)(vector); } vector_f; typedef struct vector_ctr { } vector_ctr; extern vector_ctr vector_new; extern vector_f vector_type;

string string_new_reserve(num);
string string_new_cstr(cstr, num);

A A_hold(A a);
void A_drop(A a);
A hold(A a);
void drop(A a);


A A_alloc(A_t type, num count);

A object(A instance);
A data(A instance);
# 518 "../silver/A.h"
void A_push_type(A_t type);

A_f** A_types(num* length);
member_t* A_member(A_t type, enum A_TYPE member_type, char* name);
A A_method(A_t type, char* method_name, array args);
A A_primitive(A_t type, void* data);
A A_enum(A_t enum_type, i32 value);
A A_primitive_i8(i8 data);
A A_primitive_u8(u8 data);
A A_primitive_i16(i16 data);
A A_primitive_u16(u16 data);
A A_primitive_i32(i32 data);
A A_primitive_u32(u32 data);
A A_primitive_i64(i64 data);
A A_primitive_u64(u64 data);
A A_primitive_f32(f32 data);
A A_primitive_f64(f64 data);
A A_primitive_cstr(cstr data);
A A_primitive_none();
A A_primitive_bool(bool data);

void A_finish_types();
# 2 "../silver/A.c" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));
# 142 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 327 "/usr/include/ctype.h" 3 4

# 3 "../silver/A.c" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h" 1 3 4
# 4 "../silver/A.c" 2


# 5 "../silver/A.c"
static global_init_fn* call_after;
static num call_after_alloc;
static num call_after_count;
static array keywords;

void A_lazy_init(global_init_fn fn) {
    if (call_after_count == call_after_alloc) {
        global_init_fn prev = call_after;
        num alloc_prev = call_after_alloc;
        call_after = calloc(32 + (call_after_alloc << 1), sizeof(global_init_fn));
        if (prev) {
            memcpy(call_after, prev, sizeof(global_init_fn) * alloc_prev);
            free(prev);
        }
    }
    call_after[call_after_count++] = fn;
}

A_f** types;
num types_alloc;
num types_len;

void A_push_type(A_f* type) {
    if (types_alloc == types_len) {
        A_f** prev = types;
        num alloc_prev = types_alloc;
        types = calloc(32 + (types_alloc << 1), sizeof(A_f*));
        if (prev) {
            memcpy(types, prev, sizeof(A_f*) * alloc_prev);
            free(prev);
        }
    }
    types[types_len++] = type;
}

A_f** A_types(num* length) {
    *length = types_len;
    return types;
}


A A_alloc(A_f* type, num count) {
    A a = calloc(1, (type == ((struct A_f*)&A_type) ? 0 : sizeof(struct A)) + type->size * count);
    a->type = type;
    a->origin = a;
    a->object = a;
    a->data = &a[1];
    A_f* a_type = &A_type;
    A_f* current = type;
    while (current) {
        if (current->init)
            current->init(a->data);
        if (current == a_type)
            break;
        current = current->parent;
    }
    return a->data;
}

void A_finish_types() {
    num types_len;
    A_f** types = A_types(&types_len);
    const num max_args = 8;


    for (num i = 0; i < types_len; i++) {
        A_f* type = types[i];


        for (num m = 0; m < type->member_count; m++) {
            member_t* mem = &type->members[m];
            if (mem->member_type & (A_TYPE_IMETHOD | A_TYPE_SMETHOD | A_TYPE_CONSTRUCT)) {

                mem->method = calloc(1, sizeof(method_t));
                mem->method->ffi_cif = calloc(1, sizeof(ffi_cif));
                mem->method->ffi_args = calloc(max_args, sizeof(ffi_type*));
                ffi_type **arg_types = (ffi_type**)mem->method->ffi_args;
                for (num i = 0; i < mem->args.count; i++) {
                    A_f* a_type = ((A_f**)&mem->args.arg_0)[i];
                    bool is_prim = a_type->traits & (1 << 0);
                    arg_types[i] = is_prim ? a_type->arb : &ffi_type_pointer;
                }
                ffi_status status = ffi_prep_cif(
                    (ffi_cif*) mem->method->ffi_cif, FFI_DEFAULT_ABI, mem->args.count,
                    (ffi_type*)mem->type->arb, arg_types);
                
# 90 "../silver/A.c" 3 4
               ((void) sizeof ((
# 90 "../silver/A.c"
               status == FFI_OK
# 90 "../silver/A.c" 3 4
               ) ? 1 : 0), __extension__ ({ if (
# 90 "../silver/A.c"
               status == FFI_OK
# 90 "../silver/A.c" 3 4
               ) ; else __assert_fail (
# 90 "../silver/A.c"
               "status == FFI_OK"
# 90 "../silver/A.c" 3 4
               , "../silver/A.c", 90, __extension__ __PRETTY_FUNCTION__); }))
# 90 "../silver/A.c"
                                       ;
                memcpy(&mem->method->address, &((u8*)type)[mem->offset], sizeof(void*));
                
# 92 "../silver/A.c" 3 4
               ((void) sizeof ((
# 92 "../silver/A.c"
               mem->method->address
# 92 "../silver/A.c" 3 4
               ) ? 1 : 0), __extension__ ({ if (
# 92 "../silver/A.c"
               mem->method->address
# 92 "../silver/A.c" 3 4
               ) ; else __assert_fail (
# 92 "../silver/A.c"
               "mem->method->address"
# 92 "../silver/A.c" 3 4
               , "../silver/A.c", 92, __extension__ __PRETTY_FUNCTION__); }))
# 92 "../silver/A.c"
                                           ;
            }
        }
    }
}

member_t* A_member(A_f* type, enum A_TYPE member_type, char* name) {
    for (num i = 0; i < type->member_count; i++) {
        member_t* mem = &type->members[i];
        if (mem->member_type & member_type && strcmp(mem->name, name) == 0)
            return mem;
    }
    return 0;
}

A A_primitive(A_f* type, void* data) {
    
# 108 "../silver/A.c" 3 4
   ((void) sizeof ((
# 108 "../silver/A.c"
   type->traits & (1 << 0)
# 108 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 108 "../silver/A.c"
   type->traits & (1 << 0)
# 108 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 108 "../silver/A.c"
   "type->traits & A_TRAIT_PRIMITIVE"
# 108 "../silver/A.c" 3 4
   , "../silver/A.c", 108, __extension__ __PRETTY_FUNCTION__); }))
# 108 "../silver/A.c"
                                           ;
    A copy = A_alloc(type, type->size);
    memcpy(copy, data, type->size);
    return copy;
}

A A_enum(A_f* type, i32 data) {
    
# 115 "../silver/A.c" 3 4
   ((void) sizeof ((
# 115 "../silver/A.c"
   type->traits & (1 << 1)
# 115 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 115 "../silver/A.c"
   type->traits & (1 << 1)
# 115 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 115 "../silver/A.c"
   "type->traits & A_TRAIT_ENUM"
# 115 "../silver/A.c" 3 4
   , "../silver/A.c", 115, __extension__ __PRETTY_FUNCTION__); }))
# 115 "../silver/A.c"
                                      ;
    
# 116 "../silver/A.c" 3 4
   ((void) sizeof ((
# 116 "../silver/A.c"
   type->size == sizeof(i32)
# 116 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 116 "../silver/A.c"
   type->size == sizeof(i32)
# 116 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 116 "../silver/A.c"
   "type->size == sizeof(i32)"
# 116 "../silver/A.c" 3 4
   , "../silver/A.c", 116, __extension__ __PRETTY_FUNCTION__); }))
# 116 "../silver/A.c"
                                    ;
    A copy = A_alloc(type, type->size);
    memcpy(copy, &data, type->size);
    return copy;
}

A A_primitive_i8(i8 data) { return A_primitive(&i8_type, &data); }
A A_primitive_u8(u8 data) { return A_primitive(&u8_type, &data); }
A A_primitive_i16(i16 data) { return A_primitive(&i16_type, &data); }
A A_primitive_u16(u16 data) { return A_primitive(&u16_type, &data); }
A A_primitive_i32(i32 data) { return A_primitive(&i32_type, &data); }
A A_primitive_u32(u32 data) { return A_primitive(&u32_type, &data); }
A A_primitive_i64(i64 data) { return A_primitive(&i64_type, &data); }
A A_primitive_u64(u64 data) { return A_primitive(&u64_type, &data); }
A A_primitive_f32(f32 data) { return A_primitive(&f32_type, &data); }
A A_primitive_f64(f64 data) { return A_primitive(&f64_type, &data); }
A A_primitive_cstr(cstr data) { return A_primitive(&cstr_type, &data); }
A A_primitive_none() { return A_primitive(&none_type, &data); }
A A_primitive_bool(bool data) { return A_primitive(&bool_type, &data); }


A A_method(A_f* type, char* method_name, array args) {
    member_t* mem = A_member(type, A_TYPE_IMETHOD | A_TYPE_SMETHOD, method_name);
    
# 139 "../silver/A.c" 3 4
   ((void) sizeof ((
# 139 "../silver/A.c"
   mem
# 139 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 139 "../silver/A.c"
   mem
# 139 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 139 "../silver/A.c"
   "mem"
# 139 "../silver/A.c" 3 4
   , "../silver/A.c", 139, __extension__ __PRETTY_FUNCTION__); }))
# 139 "../silver/A.c"
              ;
    const num max_args = 8;
    void* arg_values[max_args];

    
# 143 "../silver/A.c" 3 4
   ((void) sizeof ((
# 143 "../silver/A.c"
   args->len <= max_args
# 143 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 143 "../silver/A.c"
   args->len <= max_args
# 143 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 143 "../silver/A.c"
   "args->len <= max_args"
# 143 "../silver/A.c" 3 4
   , "../silver/A.c", 143, __extension__ __PRETTY_FUNCTION__); }))
# 143 "../silver/A.c"
                                ;
    
# 144 "../silver/A.c" 3 4
   ((void) sizeof ((
# 144 "../silver/A.c"
   args->len == mem->args.count
# 144 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 144 "../silver/A.c"
   args->len == mem->args.count
# 144 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 144 "../silver/A.c"
   "args->len == mem->args.count"
# 144 "../silver/A.c" 3 4
   , "../silver/A.c", 144, __extension__ __PRETTY_FUNCTION__); }))
# 144 "../silver/A.c"
                                       ;
    for (num i = 0; i < args->len; i++) {
        A_f** method_args = &mem->args.arg_0;
        A_f* arg_type = method_args[i];
        arg_values[i] = (arg_type->traits & ((1 << 0) | (1 << 1))) ?
            (void*)args->elements[i] : (void*)&args->elements[i];
    }

    void* result[8];
    ffi_call((ffi_cif*)mem->method->ffi_cif, mem->method->address, result, arg_values);
    if (mem->type->traits & (1 << 0))
        return A_primitive(mem->type, result);
    else if (mem->type->traits & (1 << 1))
        return A_enum(mem->type, *(i32*)result);
    else
        return (A) result[0];
}

A A_data(A origin_instance) {
    A a = object(origin_instance);
    return a->data;
}


A A_resize(A base_instance, num count) {
    A a = object(base_instance);
    A_f* type = a->type;
    u8* data = base_instance;

    if (a->count) {
        if (a->count > count) {

            for (num i = a->count - (a->count - count); i < a->count; i++) {
                A instance = &((u8*)a->data)[i * type->size];
                type->destructor(instance);
            }
        }
    }
    a->count = count;
}



A A_hold (A a) { ++a->refs; return a; }
static A A_default (A_t type, num count) {
    return A_alloc(type, count);
}
static void A_init (A a) { }
static void A_destructor(A a) { }
static u64 A_hash (A a) { return (u64)(size_t)a; }
static bool A_boolean (A a) { return (bool)(size_t)a; }


static i32 A_compare(A a, A b) {
    return (i32)(size_t)(a - b);
}

static void string_init(string a) { printf("init string\n"); }
static void string_destructor(string a) { free(a->chars); }
static num string_compare(string a, string b) { return strcmp(a->chars, b->chars); }
static array string_split(string a, A sp) {
    return ((void*)0);
}

u64 fnv1a_hash(const void* data, size_t length, u64 hash) {
    const u8* bytes = (const u8*)data;
    for (size_t i = 0; i < length; ++i) {
        hash ^= bytes[i];
        hash *= 0x100000001b3;
    }
    return hash;
}

static u64 string_hash(string a) {
    if (a->h) return a->h;
    a->h = fnv1a_hash(a->chars, a->len, 0xcbf29ce484222325);
    return a->h;
}

string string_new_reserve(num sz) {
    string a = ((string)A_alloc(((struct A_f*)&string_type), 1));
    a->alloc = sz;
    a->chars = (char*)calloc(1, a->alloc);
    return a;
}

string string_new_cstr(cstr value, num len) {
    if (len == -1) len = strlen(value);
    string a = ((string)A_alloc(((struct A_f*)&string_type), 1));
    a->alloc = len + 1;
    a->chars = (char*)calloc(1, a->alloc);
    memcpy(a->chars, value, len);
    a->chars[len] = 0;
    return a;
}


static void collection_push(collection a, A b) {
    
# 242 "../silver/A.c" 3 4
   ((void) sizeof ((
# 242 "../silver/A.c"
   (bool)0
# 242 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 242 "../silver/A.c"
   (bool)0
# 242 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 242 "../silver/A.c"
   "false"
# 242 "../silver/A.c" 3 4
   , "../silver/A.c", 242, __extension__ __PRETTY_FUNCTION__); }))
# 242 "../silver/A.c"
                ;
}

static A collection_pop(collection a) {
    
# 246 "../silver/A.c" 3 4
   ((void) sizeof ((
# 246 "../silver/A.c"
   (bool)0
# 246 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 246 "../silver/A.c"
   (bool)0
# 246 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 246 "../silver/A.c"
   "false"
# 246 "../silver/A.c" 3 4
   , "../silver/A.c", 246, __extension__ __PRETTY_FUNCTION__); }))
# 246 "../silver/A.c"
                ;
    return ((void*)0);
}

static num collection_compare(array a, collection b) {
    
# 251 "../silver/A.c" 3 4
   ((void) sizeof ((
# 251 "../silver/A.c"
   (bool)0
# 251 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 251 "../silver/A.c"
   (bool)0
# 251 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 251 "../silver/A.c"
   "false"
# 251 "../silver/A.c" 3 4
   , "../silver/A.c", 251, __extension__ __PRETTY_FUNCTION__); }))
# 251 "../silver/A.c"
                ;
    return 0;
}

A hold(A a) {
    (a - 1)->refs++;
    return a;
}

void drop(A a) {
    if (--(a - 1)->refs == -1) {
        A aa = (a - 1);
        A_f* type = aa->type;
        void* prev = ((void*)0);
        while (type) {
            if (prev != type->destructor) {
                type->destructor(a);
                prev = type->destructor;
            }
            if (type == &A_type)
                break;
            type = type->parent;
        }
        free(aa);
    }
}

A data(A instance) {
    return object(instance)->data;
}


A object(A instance) {
    return instance - 1;
}


static void list_push(list a, A e) {
    item n = ((item)A_alloc(((struct A_f*)&item_type), 1));
    n->element = e;
    if (a->last) {
        a->last->next = n;
        n->prev = a->last;
    } else {
        a->first = n;
    }
    a->last = n;
    a->count++;
}

static num list_compare(list a, list b) {
    num diff = a->count - b->count;
    if (diff != 0)
        return diff;
    for (item ai = a->first, bi = b->first; ai; ai = ai->next, bi = bi->next) {
        A_f* ai_t = *(A_f**)&((A)ai->element)[-1];
        num cmp = ai_t->compare(ai, bi);
        if (cmp != 0) return cmp;
    }
    return 0;
}

static A list_pop(list a) {
    item l = a->last;
    a->last = a->last->prev;
    if (!a->last)
        a->first = ((void*)0);
    l->prev = ((void*)0);
    a->count--;
    return l;
}

static A list_get(list a, num at_index) {
    num index = 0;
    for (item i = a->first; i; i = i->next) {
        if (at_index == index)
            return i->element;
        index++;
    }
    
# 330 "../silver/A.c" 3 4
   ((void) sizeof ((
# 330 "../silver/A.c"
   (bool)0
# 330 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 330 "../silver/A.c"
   (bool)0
# 330 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 330 "../silver/A.c"
   "false"
# 330 "../silver/A.c" 3 4
   , "../silver/A.c", 330, __extension__ __PRETTY_FUNCTION__); }))
# 330 "../silver/A.c"
                ;
    return ((void*)0);
}

static num list_count(list a) {
    return a->count;
}


static void array_expand(array a) {
    num alloc = 32 + (a->alloc << 1);
    A* elements = (A*)calloc(alloc, sizeof(struct A*));
    memcpy(elements, a->elements, sizeof(struct A*) * a->len);
    free(a->elements);
    a->elements = elements;
    a->alloc = alloc;
}

static void array_push(array a, A b) {
    if (a->alloc == a->len) {
        array_expand(a);
    }
    a->elements[a->len++] = b;
}

static void array_push_symbols(array a, char* f, ...) {
    va_list args;
    
# 357 "../silver/A.c" 3 4
   __builtin_va_start(
# 357 "../silver/A.c"
   args
# 357 "../silver/A.c" 3 4
   ,
# 357 "../silver/A.c"
   f
# 357 "../silver/A.c" 3 4
   )
# 357 "../silver/A.c"
                    ;
    char* value;
    while ((value = 
# 359 "../silver/A.c" 3 4
                   __builtin_va_arg(
# 359 "../silver/A.c"
                   args
# 359 "../silver/A.c" 3 4
                   ,
# 359 "../silver/A.c"
                   char*
# 359 "../silver/A.c" 3 4
                   )
# 359 "../silver/A.c"
                                      ) != ((void*)0))
        ((array_f*)((A)a)[-1].type) -> push(a, string_new_cstr(value, strlen(value)));
    
# 361 "../silver/A.c" 3 4
   __builtin_va_end(
# 361 "../silver/A.c"
   args
# 361 "../silver/A.c" 3 4
   )
# 361 "../silver/A.c"
               ;
}

static void array_push_objects(array a, A f, ...) {
    va_list args;
    
# 366 "../silver/A.c" 3 4
   __builtin_va_start(
# 366 "../silver/A.c"
   args
# 366 "../silver/A.c" 3 4
   ,
# 366 "../silver/A.c"
   f
# 366 "../silver/A.c" 3 4
   )
# 366 "../silver/A.c"
                    ;
    A value;
    while ((value = 
# 368 "../silver/A.c" 3 4
                   __builtin_va_arg(
# 368 "../silver/A.c"
                   args
# 368 "../silver/A.c" 3 4
                   ,
# 368 "../silver/A.c"
                   A
# 368 "../silver/A.c" 3 4
                   )
# 368 "../silver/A.c"
                                  ) != ((void*)0))
        ((array_f*)((A)a)[-1].type) -> push(a, hold(value));
    
# 370 "../silver/A.c" 3 4
   __builtin_va_end(
# 370 "../silver/A.c"
   args
# 370 "../silver/A.c" 3 4
   )
# 370 "../silver/A.c"
               ;
}

static A array_pop(array a) {
    
# 374 "../silver/A.c" 3 4
   ((void) sizeof ((
# 374 "../silver/A.c"
   a->len > 0
# 374 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 374 "../silver/A.c"
   a->len > 0
# 374 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 374 "../silver/A.c"
   "a->len > 0"
# 374 "../silver/A.c" 3 4
   , "../silver/A.c", 374, __extension__ __PRETTY_FUNCTION__); }))
# 374 "../silver/A.c"
                     ;
    return a->elements[a->len--];
}

static num array_compare(array a, array b) {
    num diff = a->len - b->len;
    if (diff != 0)
        return diff;
    for (num i = 0; i < a->len; i++) {
        num cmp = ((A_f*)((A)a->elements[i])[-1].type) -> compare(a->elements[i], b->elements[i]);
        if (cmp != 0)
            return cmp;
    }
    return 0;
}

static A array_get(array a, num i) {
    return a->elements[i];
}

static num array_count(array a) {
    return a->len;
}


static num array_index_of(array a, A b) {
    for (num i = 0; i < a->len; i++) {
        if (a -> elements[i] == b)
            return i;
    }
    return -1;
}

static array array_with_cstr(cstr value) {
    printf("cstr = %s\n", value);
    return ((void*)0);
}

static bool array_boolean(array a) { return a && a->len > 0; }


A_ctr A_new; A_f A_type; static __attribute__((constructor)) bool global_A() { A_f* type_ref = &A_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_A); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(A_type) / sizeof(void*)]; A_type.parent = & A_type; A_type.name = "A"; A_type.size = sizeof(struct A); A_type.members = members; A_type.traits = 0; A_type.arb = &ffi_type_pointer; A_new . A_default = & A_default; 
# 415 "../silver/A.c" 3 4
((void) sizeof ((
# 415 "../silver/A.c"
"A" == "A"
# 415 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 415 "../silver/A.c"
"A" == "A"
# 415 "../silver/A.c" 3 4
) ; else __assert_fail (
# 415 "../silver/A.c"
"\"A\" == \"A\""
# 415 "../silver/A.c" 3 4
, "../silver/A.c", 415, __extension__ __PRETTY_FUNCTION__); }))
# 415 "../silver/A.c"
; A_type.members[A_type.member_count].name = "default"; A_type.members[A_type.member_count].args = (args_t) { 2, &AType_type, &num_type }; A_type.members[A_type.member_count].type = &A_type; A_type.members[A_type.member_count].offset = 
# 415 "../silver/A.c" 3 4
__builtin_offsetof (
# 415 "../silver/A.c"
A_ctr
# 415 "../silver/A.c" 3 4
, 
# 415 "../silver/A.c"
A_default
# 415 "../silver/A.c" 3 4
)
# 415 "../silver/A.c"
; A_type.members[A_type.member_count].member_type = A_TYPE_CONSTRUCT; A_type.member_count++; A_type . init = & A_init; A_type.members[A_type.member_count].name = "init"; A_type.members[A_type.member_count].args = (args_t) { 1, &A_type }; A_type.members[A_type.member_count].type = &none_type; A_type.members[A_type.member_count].offset = 
# 415 "../silver/A.c" 3 4
__builtin_offsetof (
# 415 "../silver/A.c"
A_f
# 415 "../silver/A.c" 3 4
, 
# 415 "../silver/A.c"
init
# 415 "../silver/A.c" 3 4
)
# 415 "../silver/A.c"
; A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type . destructor = & A_destructor; A_type.members[A_type.member_count].name = "destructor"; A_type.members[A_type.member_count].args = (args_t) { 1, &A_type }; A_type.members[A_type.member_count].type = &none_type; A_type.members[A_type.member_count].offset = 
# 415 "../silver/A.c" 3 4
__builtin_offsetof (
# 415 "../silver/A.c"
A_f
# 415 "../silver/A.c" 3 4
, 
# 415 "../silver/A.c"
destructor
# 415 "../silver/A.c" 3 4
)
# 415 "../silver/A.c"
; A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type . compare = & A_compare; A_type.members[A_type.member_count].name = "compare"; A_type.members[A_type.member_count].args = (args_t) { 2, &A_type, &A_type }; A_type.members[A_type.member_count].type = &i32_type; A_type.members[A_type.member_count].offset = 
# 415 "../silver/A.c" 3 4
__builtin_offsetof (
# 415 "../silver/A.c"
A_f
# 415 "../silver/A.c" 3 4
, 
# 415 "../silver/A.c"
compare
# 415 "../silver/A.c" 3 4
)
# 415 "../silver/A.c"
; A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type . hash = & A_hash; A_type.members[A_type.member_count].name = "hash"; A_type.members[A_type.member_count].args = (args_t) { 1, &A_type }; A_type.members[A_type.member_count].type = &u64_type; A_type.members[A_type.member_count].offset = 
# 415 "../silver/A.c" 3 4
__builtin_offsetof (
# 415 "../silver/A.c"
A_f
# 415 "../silver/A.c" 3 4
, 
# 415 "../silver/A.c"
hash
# 415 "../silver/A.c" 3 4
)
# 415 "../silver/A.c"
; A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++; A_type . boolean = & A_boolean; A_type.members[A_type.member_count].name = "boolean"; A_type.members[A_type.member_count].args = (args_t) { 1, &A_type }; A_type.members[A_type.member_count].type = &bool_type; A_type.members[A_type.member_count].offset = 
# 415 "../silver/A.c" 3 4
__builtin_offsetof (
# 415 "../silver/A.c"
A_f
# 415 "../silver/A.c" 3 4
, 
# 415 "../silver/A.c"
boolean
# 415 "../silver/A.c" 3 4
)
# 415 "../silver/A.c"
; A_type.members[A_type.member_count].member_type = A_TYPE_IMETHOD; A_type.member_count++;; A_push_type(&A_type); return (bool)1; } }
string_ctr string_new; string_f string_type; static __attribute__((constructor)) bool global_string() { string_f* type_ref = &string_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_string); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(string_type) / sizeof(void*)]; string_type.parent = & A_type; string_type.name = "string"; string_type.size = sizeof(struct string); string_type.members = members; string_type.traits = 0; string_type.arb = &ffi_type_pointer; string_type . split = & string_split; string_type.members[string_type.member_count].name = "split"; string_type.members[string_type.member_count].args = (args_t) { 2, &string_type, &A_type }; string_type.members[string_type.member_count].type = &array_type; string_type.members[string_type.member_count].offset = 
# 416 "../silver/A.c" 3 4
__builtin_offsetof (
# 416 "../silver/A.c"
string_f
# 416 "../silver/A.c" 3 4
, 
# 416 "../silver/A.c"
split
# 416 "../silver/A.c" 3 4
)
# 416 "../silver/A.c"
; string_type.members[string_type.member_count].member_type = A_TYPE_IMETHOD; string_type.member_count++; string_type . hash = & string_hash;; A_push_type(&string_type); return (bool)1; } }
item_ctr item_new; item_f item_type; static __attribute__((constructor)) bool global_item() { item_f* type_ref = &item_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_item); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(item_type) / sizeof(void*)]; item_type.parent = & A_type; item_type.name = "item"; item_type.size = sizeof(struct item); item_type.members = members; item_type.traits = 0; item_type.arb = &ffi_type_pointer; ; A_push_type(&item_type); return (bool)1; } }
collection_f collection_type; static __attribute__((constructor)) bool global_collection() { collection_f* type_ref = &collection_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_collection); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(collection_type) / sizeof(void*)]; collection_type.parent = & A_type; collection_type.name = "collection"; collection_type.size = sizeof(struct collection); collection_type.members = members; collection_type.traits = 0; ; A_push_type(&collection_type); return (bool)1; } }
list_ctr list_new; list_f list_type; static __attribute__((constructor)) bool global_list() { list_f* type_ref = &list_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_list); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(list_type) / sizeof(void*)]; list_type.parent = & A_type; list_type.name = "list"; list_type.size = sizeof(struct list); list_type.members = members; list_type.traits = 0; list_type.arb = &ffi_type_pointer; list_type.members[list_type.member_count].name = "public_integer"; list_type.members[list_type.member_count].offset = 
# 419 "../silver/A.c" 3 4
__builtin_offsetof (
# 419 "../silver/A.c"
struct list
# 419 "../silver/A.c" 3 4
, 
# 419 "../silver/A.c"
public_integer
# 419 "../silver/A.c" 3 4
)
# 419 "../silver/A.c"
; list_type.members[list_type.member_count].type = &i32_type; list_type.members[list_type.member_count].member_type = A_TYPE_PROP; list_type.member_count++; list_type . pop = & list_pop; list_type.members[list_type.member_count].name = "pop"; list_type.members[list_type.member_count].args = (args_t) { 1, &list_type }; list_type.members[list_type.member_count].type = &A_type; list_type.members[list_type.member_count].offset = 
# 419 "../silver/A.c" 3 4
__builtin_offsetof (
# 419 "../silver/A.c"
list_f
# 419 "../silver/A.c" 3 4
, 
# 419 "../silver/A.c"
pop
# 419 "../silver/A.c" 3 4
)
# 419 "../silver/A.c"
; list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . push = & list_push; list_type.members[list_type.member_count].name = "push"; list_type.members[list_type.member_count].args = (args_t) { 2, &list_type, &A_type }; list_type.members[list_type.member_count].type = &none_type; list_type.members[list_type.member_count].offset = 
# 419 "../silver/A.c" 3 4
__builtin_offsetof (
# 419 "../silver/A.c"
list_f
# 419 "../silver/A.c" 3 4
, 
# 419 "../silver/A.c"
push
# 419 "../silver/A.c" 3 4
)
# 419 "../silver/A.c"
; list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . get = & list_get; list_type.members[list_type.member_count].name = "get"; list_type.members[list_type.member_count].args = (args_t) { 2, &list_type, &i32_type }; list_type.members[list_type.member_count].type = &A_type; list_type.members[list_type.member_count].offset = 
# 419 "../silver/A.c" 3 4
__builtin_offsetof (
# 419 "../silver/A.c"
list_f
# 419 "../silver/A.c" 3 4
, 
# 419 "../silver/A.c"
get
# 419 "../silver/A.c" 3 4
)
# 419 "../silver/A.c"
; list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++; list_type . count = & list_count; list_type.members[list_type.member_count].name = "count"; list_type.members[list_type.member_count].args = (args_t) { 1, &list_type }; list_type.members[list_type.member_count].type = &num_type; list_type.members[list_type.member_count].offset = 
# 419 "../silver/A.c" 3 4
__builtin_offsetof (
# 419 "../silver/A.c"
list_f
# 419 "../silver/A.c" 3 4
, 
# 419 "../silver/A.c"
count
# 419 "../silver/A.c" 3 4
)
# 419 "../silver/A.c"
; list_type.members[list_type.member_count].member_type = A_TYPE_IMETHOD; list_type.member_count++;; A_push_type(&list_type); return (bool)1; } }
array_ctr array_new; array_f array_type; static __attribute__((constructor)) bool global_array() { array_f* type_ref = &array_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_array); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(array_type) / sizeof(void*)]; array_type.parent = & A_type; array_type.name = "array"; array_type.size = sizeof(struct array); array_type.members = members; array_type.traits = 0; array_type.arb = &ffi_type_pointer; array_type . pop = & array_pop; array_type.members[array_type.member_count].name = "pop"; array_type.members[array_type.member_count].args = (args_t) { 1, &array_type }; array_type.members[array_type.member_count].type = &array_type; array_type.members[array_type.member_count].offset = 
# 420 "../silver/A.c" 3 4
__builtin_offsetof (
# 420 "../silver/A.c"
array_f
# 420 "../silver/A.c" 3 4
, 
# 420 "../silver/A.c"
pop
# 420 "../silver/A.c" 3 4
)
# 420 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . push = & array_push; array_type.members[array_type.member_count].name = "push"; array_type.members[array_type.member_count].args = (args_t) { 2, &array_type, &A_type }; array_type.members[array_type.member_count].type = &none_type; array_type.members[array_type.member_count].offset = 
# 420 "../silver/A.c" 3 4
__builtin_offsetof (
# 420 "../silver/A.c"
array_f
# 420 "../silver/A.c" 3 4
, 
# 420 "../silver/A.c"
push
# 420 "../silver/A.c" 3 4
)
# 420 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . get = & array_get; array_type.members[array_type.member_count].name = "get"; array_type.members[array_type.member_count].args = (args_t) { 2, &array_type, &i32_type }; array_type.members[array_type.member_count].type = &A_type; array_type.members[array_type.member_count].offset = 
# 420 "../silver/A.c" 3 4
__builtin_offsetof (
# 420 "../silver/A.c"
array_f
# 420 "../silver/A.c" 3 4
, 
# 420 "../silver/A.c"
get
# 420 "../silver/A.c" 3 4
)
# 420 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . count = & array_count; array_type.members[array_type.member_count].name = "count"; array_type.members[array_type.member_count].args = (args_t) { 1, &array_type }; array_type.members[array_type.member_count].type = &array_type; array_type.members[array_type.member_count].offset = 
# 420 "../silver/A.c" 3 4
__builtin_offsetof (
# 420 "../silver/A.c"
array_f
# 420 "../silver/A.c" 3 4
, 
# 420 "../silver/A.c"
count
# 420 "../silver/A.c" 3 4
)
# 420 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . index_of = & array_index_of; array_type.members[array_type.member_count].name = "index_of"; array_type.members[array_type.member_count].args = (args_t) { 2, &array_type, &A_type }; array_type.members[array_type.member_count].type = &num_type; array_type.members[array_type.member_count].offset = 
# 420 "../silver/A.c" 3 4
__builtin_offsetof (
# 420 "../silver/A.c"
array_f
# 420 "../silver/A.c" 3 4
, 
# 420 "../silver/A.c"
index_of
# 420 "../silver/A.c" 3 4
)
# 420 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_new . array_with_cstr = & array_with_cstr; 
# 420 "../silver/A.c" 3 4
((void) sizeof ((
# 420 "../silver/A.c"
"array" == "array"
# 420 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 420 "../silver/A.c"
"array" == "array"
# 420 "../silver/A.c" 3 4
) ; else __assert_fail (
# 420 "../silver/A.c"
"\"array\" == \"array\""
# 420 "../silver/A.c" 3 4
, "../silver/A.c", 420, __extension__ __PRETTY_FUNCTION__); }))
# 420 "../silver/A.c"
; array_type.members[array_type.member_count].name = "with_cstr"; array_type.members[array_type.member_count].args = (args_t) { 3, &AType_type, &num_type, &cstr_type }; array_type.members[array_type.member_count].type = &array_type; array_type.members[array_type.member_count].offset = 
# 420 "../silver/A.c" 3 4
__builtin_offsetof (
# 420 "../silver/A.c"
array_ctr
# 420 "../silver/A.c" 3 4
, 
# 420 "../silver/A.c"
array_with_cstr
# 420 "../silver/A.c" 3 4
)
# 420 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_CONSTRUCT; array_type.member_count++; array_type . push_symbols = & array_push_symbols; array_type.members[array_type.member_count].name = "push_symbols"; array_type.members[array_type.member_count].args = (args_t) { 2, &array_type, &cstr_type }; array_type.members[array_type.member_count].type = &none_type; array_type.members[array_type.member_count].offset = 
# 420 "../silver/A.c" 3 4
__builtin_offsetof (
# 420 "../silver/A.c"
array_f
# 420 "../silver/A.c" 3 4
, 
# 420 "../silver/A.c"
push_symbols
# 420 "../silver/A.c" 3 4
)
# 420 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . push_objects = & array_push_objects; array_type.members[array_type.member_count].name = "push_objects"; array_type.members[array_type.member_count].args = (args_t) { 2, &array_type, &A_type }; array_type.members[array_type.member_count].type = &none_type; array_type.members[array_type.member_count].offset = 
# 420 "../silver/A.c" 3 4
__builtin_offsetof (
# 420 "../silver/A.c"
array_f
# 420 "../silver/A.c" 3 4
, 
# 420 "../silver/A.c"
push_objects
# 420 "../silver/A.c" 3 4
)
# 420 "../silver/A.c"
; array_type.members[array_type.member_count].member_type = A_TYPE_IMETHOD; array_type.member_count++; array_type . boolean = & array_boolean;; A_push_type(&array_type); return (bool)1; } }

u8_f u8_type; static __attribute__((constructor)) bool global_u8() { u8_f* type_ref = &u8_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_u8); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(u8_type) / sizeof(void*)]; u8_type.parent = & A_type; u8_type.name = "u8"; u8_type.size = sizeof(u8); u8_type.members = members; u8_type.traits = (1 << 0); u8_type.arb = &ffi_type_uint8; A_push_type(&u8_type); return (bool)1; } }
u16_f u16_type; static __attribute__((constructor)) bool global_u16() { u16_f* type_ref = &u16_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_u16); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(u16_type) / sizeof(void*)]; u16_type.parent = & A_type; u16_type.name = "u16"; u16_type.size = sizeof(u16); u16_type.members = members; u16_type.traits = (1 << 0); u16_type.arb = &ffi_type_uint16; A_push_type(&u16_type); return (bool)1; } }
u32_f u32_type; static __attribute__((constructor)) bool global_u32() { u32_f* type_ref = &u32_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_u32); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(u32_type) / sizeof(void*)]; u32_type.parent = & A_type; u32_type.name = "u32"; u32_type.size = sizeof(u32); u32_type.members = members; u32_type.traits = (1 << 0); u32_type.arb = &ffi_type_uint32; A_push_type(&u32_type); return (bool)1; } }
u64_f u64_type; static __attribute__((constructor)) bool global_u64() { u64_f* type_ref = &u64_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_u64); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(u64_type) / sizeof(void*)]; u64_type.parent = & A_type; u64_type.name = "u64"; u64_type.size = sizeof(u64); u64_type.members = members; u64_type.traits = (1 << 0); u64_type.arb = &ffi_type_uint64; A_push_type(&u64_type); return (bool)1; } }
i8_f i8_type; static __attribute__((constructor)) bool global_i8() { i8_f* type_ref = &i8_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_i8); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(i8_type) / sizeof(void*)]; i8_type.parent = & A_type; i8_type.name = "i8"; i8_type.size = sizeof(i8); i8_type.members = members; i8_type.traits = (1 << 0); i8_type.arb = &ffi_type_sint8; A_push_type(&i8_type); return (bool)1; } }
i16_f i16_type; static __attribute__((constructor)) bool global_i16() { i16_f* type_ref = &i16_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_i16); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(i16_type) / sizeof(void*)]; i16_type.parent = & A_type; i16_type.name = "i16"; i16_type.size = sizeof(i16); i16_type.members = members; i16_type.traits = (1 << 0); i16_type.arb = &ffi_type_sint16; A_push_type(&i16_type); return (bool)1; } }
i32_f i32_type; static __attribute__((constructor)) bool global_i32() { i32_f* type_ref = &i32_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_i32); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(i32_type) / sizeof(void*)]; i32_type.parent = & A_type; i32_type.name = "i32"; i32_type.size = sizeof(i32); i32_type.members = members; i32_type.traits = (1 << 0); i32_type.arb = &ffi_type_sint32; A_push_type(&i32_type); return (bool)1; } }
i64_f i64_type; static __attribute__((constructor)) bool global_i64() { i64_f* type_ref = &i64_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_i64); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(i64_type) / sizeof(void*)]; i64_type.parent = & A_type; i64_type.name = "i64"; i64_type.size = sizeof(i64); i64_type.members = members; i64_type.traits = (1 << 0); i64_type.arb = &ffi_type_sint64; A_push_type(&i64_type); return (bool)1; } }
f32_f f32_type; static __attribute__((constructor)) bool global_f32() { f32_f* type_ref = &f32_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_f32); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(f32_type) / sizeof(void*)]; f32_type.parent = & A_type; f32_type.name = "f32"; f32_type.size = sizeof(f32); f32_type.members = members; f32_type.traits = (1 << 0); f32_type.arb = &ffi_type_float; A_push_type(&f32_type); return (bool)1; } }
f64_f f64_type; static __attribute__((constructor)) bool global_f64() { f64_f* type_ref = &f64_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_f64); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(f64_type) / sizeof(void*)]; f64_type.parent = & A_type; f64_type.name = "f64"; f64_type.size = sizeof(f64); f64_type.members = members; f64_type.traits = (1 << 0); f64_type.arb = &ffi_type_double; A_push_type(&f64_type); return (bool)1; } }
f128_f f128_type; static __attribute__((constructor)) bool global_f128() { f128_f* type_ref = &f128_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_f128); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(f128_type) / sizeof(void*)]; f128_type.parent = & A_type; f128_type.name = "f128"; f128_type.size = sizeof(f128); f128_type.members = members; f128_type.traits = (1 << 0); f128_type.arb = &ffi_type_longdouble; A_push_type(&f128_type); return (bool)1; } }
cstr_f cstr_type; static __attribute__((constructor)) bool global_cstr() { cstr_f* type_ref = &cstr_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_cstr); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(cstr_type) / sizeof(void*)]; cstr_type.parent = & A_type; cstr_type.name = "cstr"; cstr_type.size = sizeof(cstr); cstr_type.members = members; cstr_type.traits = (1 << 0); cstr_type.arb = &ffi_type_pointer; A_push_type(&cstr_type); return (bool)1; } }
bool_f bool_type; static __attribute__((constructor)) bool global_bool() { bool_f* type_ref = &bool_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_bool); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(bool_type) / sizeof(void*)]; bool_type.parent = & A_type; bool_type.name = "bool"; bool_type.size = sizeof(bool); bool_type.members = members; bool_type.traits = (1 << 0); bool_type.arb = &ffi_type_uint32; A_push_type(&bool_type); return (bool)1; } }
num_f num_type; static __attribute__((constructor)) bool global_num() { num_f* type_ref = &num_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_num); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(num_type) / sizeof(void*)]; num_type.parent = & A_type; num_type.name = "num"; num_type.size = sizeof(num); num_type.members = members; num_type.traits = (1 << 0); num_type.arb = &ffi_type_sint64; A_push_type(&num_type); return (bool)1; } }
none_f none_type; static __attribute__((constructor)) bool global_none() { none_f* type_ref = &none_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_none); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(none_type) / sizeof(void*)]; none_type.parent = & A_type; none_type.name = "none"; none_type.size = sizeof(none); none_type.members = members; none_type.traits = (1 << 0); none_type.arb = &ffi_type_void; A_push_type(&none_type); return (bool)1; } }
AType_f AType_type; static __attribute__((constructor)) bool global_AType() { AType_f* type_ref = &AType_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_AType); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(AType_type) / sizeof(void*)]; AType_type.parent = & A_type; AType_type.name = "AType"; AType_type.size = sizeof(AType); AType_type.members = members; AType_type.traits = (1 << 0); AType_type.arb = &ffi_type_pointer; A_push_type(&AType_type); return (bool)1; } }
# 477 "../silver/A.c"
typedef enum EType { EType_Undefined, EType_Statements, EType_Assign, EType_AssignAdd, EType_AssignSub, EType_AssignMul, EType_AssignDiv, EType_AssignOr, EType_AssignAnd, EType_AssignXor, EType_AssignShiftR, EType_AssignShiftL, EType_AssignMod, EType_If, EType_For, EType_While, EType_DoWhile, EType_Break, EType_LiteralReal, EType_LiteralInt, EType_LiteralStr, EType_LiteralStrInterp, EType_Array, EType_AlphaIdent, EType_Var, EType_Add, EType_Sub, EType_Mul, EType_Div, EType_Or, EType_And, EType_Xor, EType_MethodCall, EType_MethodReturn, } EType; typedef struct EType_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(EType); none (*destructor)(EType); i32 (*compare)(EType,EType); u64 (*hash)(EType); bool (*boolean)(EType); } EType_f; extern EType_f EType_type;

EType_f EType_type; static __attribute__((constructor)) bool global_EType() { EType_f* type_ref = &EType_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_EType); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(EType_type) / sizeof(void*)]; EType_type.parent = & A_type; EType_type.name = "EType"; EType_type.size = sizeof(enum EType); EType_type.members = members; EType_type.traits = (1 << 1); EType_type.arb = &ffi_type_sint32; EType_type.members[EType_type.member_count].name = "Undefined"; EType_type.members[EType_type.member_count].offset = EType_Undefined; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Statements"; EType_type.members[EType_type.member_count].offset = EType_Statements; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Assign"; EType_type.members[EType_type.member_count].offset = EType_Assign; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignAdd"; EType_type.members[EType_type.member_count].offset = EType_AssignAdd; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignSub"; EType_type.members[EType_type.member_count].offset = EType_AssignSub; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignMul"; EType_type.members[EType_type.member_count].offset = EType_AssignMul; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignDiv"; EType_type.members[EType_type.member_count].offset = EType_AssignDiv; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignOr"; EType_type.members[EType_type.member_count].offset = EType_AssignOr; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignAnd"; EType_type.members[EType_type.member_count].offset = EType_AssignAnd; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignXor"; EType_type.members[EType_type.member_count].offset = EType_AssignXor; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignShiftR"; EType_type.members[EType_type.member_count].offset = EType_AssignShiftR; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignShiftL"; EType_type.members[EType_type.member_count].offset = EType_AssignShiftL; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AssignMod"; EType_type.members[EType_type.member_count].offset = EType_AssignMod; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "If"; EType_type.members[EType_type.member_count].offset = EType_If; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "For"; EType_type.members[EType_type.member_count].offset = EType_For; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "While"; EType_type.members[EType_type.member_count].offset = EType_While; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "DoWhile"; EType_type.members[EType_type.member_count].offset = EType_DoWhile; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Break"; EType_type.members[EType_type.member_count].offset = EType_Break; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "LiteralReal"; EType_type.members[EType_type.member_count].offset = EType_LiteralReal; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "LiteralInt"; EType_type.members[EType_type.member_count].offset = EType_LiteralInt; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "LiteralStr"; EType_type.members[EType_type.member_count].offset = EType_LiteralStr; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "LiteralStrInterp"; EType_type.members[EType_type.member_count].offset = EType_LiteralStrInterp; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Array"; EType_type.members[EType_type.member_count].offset = EType_Array; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "AlphaIdent"; EType_type.members[EType_type.member_count].offset = EType_AlphaIdent; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Var"; EType_type.members[EType_type.member_count].offset = EType_Var; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Add"; EType_type.members[EType_type.member_count].offset = EType_Add; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Sub"; EType_type.members[EType_type.member_count].offset = EType_Sub; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Mul"; EType_type.members[EType_type.member_count].offset = EType_Mul; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Div"; EType_type.members[EType_type.member_count].offset = EType_Div; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Or"; EType_type.members[EType_type.member_count].offset = EType_Or; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "And"; EType_type.members[EType_type.member_count].offset = EType_And; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "Xor"; EType_type.members[EType_type.member_count].offset = EType_Xor; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "MethodCall"; EType_type.members[EType_type.member_count].offset = EType_MethodCall; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++; EType_type.members[EType_type.member_count].name = "MethodReturn"; EType_type.members[EType_type.member_count].offset = EType_MethodReturn; EType_type.members[EType_type.member_count].type = &i32_type; EType_type.members[EType_type.member_count].member_type = A_TYPE_ENUMV; EType_type.member_count++;; A_push_type(&EType_type); return (bool)1; } }
# 491 "../silver/A.c"

# 491 "../silver/A.c"
#pragma pack(push, 1)
# 491 "../silver/A.c"
 typedef struct ident { string value; string fname; array members_cache; int line_num; u64 h; } *ident;
# 491 "../silver/A.c"
#pragma pack(pop)
# 491 "../silver/A.c"
 typedef struct ident_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(ident); none (*destructor)(ident); i32 (*compare)(ident,ident); u64 (*hash)(ident); bool (*boolean)(ident); array (*split_members)(ident); EType (*is_numeric)(ident); EType (*is_string)(ident); } ident_f; typedef struct ident_ctr { ident (*ident_default)(struct ident_f*, num); } ident_ctr; extern ident_ctr ident_new; extern ident_f ident_type;

EType ident_is_string(ident a) {
    char* t = a->value->chars;
    return t[0] == '"' ? EType_LiteralStr : t[0] == '\'' ? EType_LiteralStrInterp : EType_Undefined;
}

EType ident_is_numeric(ident a) {
    char* t = a->value->chars;
    return (t[0] >= '0' && t[0] <= '9') ? (strchr(t, '.') ?
        EType_LiteralReal : EType_LiteralInt) : EType_Undefined;
}

u64 ident_hash(ident a) {
    if (!a->h) {
        u64 h = 0xcbf29ce484222325;
            h *= 0x100000001b3;
            h ^= ((string_f*)((A)a->value)[-1].type) -> hash(a->value);
        a->h = h;
    }
    return a->h;
}

array ident_split_members(ident a, A obj) {
    if (!a->members_cache)
        a->members_cache = ((string_f*)((A)a->value)[-1].type) -> split(a->value, obj);
    return a->members_cache;
}

ident_ctr ident_new; ident_f ident_type; static __attribute__((constructor)) bool global_ident() { ident_f* type_ref = &ident_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_ident); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(ident_type) / sizeof(void*)]; ident_type.parent = & A_type; ident_type.name = "ident"; ident_type.size = sizeof(struct ident); ident_type.members = members; ident_type.traits = 0; ident_type.arb = &ffi_type_pointer; ident_type . split_members = & ident_split_members; ident_type.members[ident_type.member_count].name = "split_members"; ident_type.members[ident_type.member_count].args = (args_t) { 1, &ident_type }; ident_type.members[ident_type.member_count].type = &array_type; ident_type.members[ident_type.member_count].offset = 
# 520 "../silver/A.c" 3 4
__builtin_offsetof (
# 520 "../silver/A.c"
ident_f
# 520 "../silver/A.c" 3 4
, 
# 520 "../silver/A.c"
split_members
# 520 "../silver/A.c" 3 4
)
# 520 "../silver/A.c"
; ident_type.members[ident_type.member_count].member_type = A_TYPE_IMETHOD; ident_type.member_count++; ident_type . is_numeric = & ident_is_numeric; ident_type.members[ident_type.member_count].name = "is_numeric"; ident_type.members[ident_type.member_count].args = (args_t) { 1, &ident_type }; ident_type.members[ident_type.member_count].type = &EType_type; ident_type.members[ident_type.member_count].offset = 
# 520 "../silver/A.c" 3 4
__builtin_offsetof (
# 520 "../silver/A.c"
ident_f
# 520 "../silver/A.c" 3 4
, 
# 520 "../silver/A.c"
is_numeric
# 520 "../silver/A.c" 3 4
)
# 520 "../silver/A.c"
; ident_type.members[ident_type.member_count].member_type = A_TYPE_IMETHOD; ident_type.member_count++; ident_type . is_string = & ident_is_string; ident_type.members[ident_type.member_count].name = "is_string"; ident_type.members[ident_type.member_count].args = (args_t) { 1, &ident_type }; ident_type.members[ident_type.member_count].type = &EType_type; ident_type.members[ident_type.member_count].offset = 
# 520 "../silver/A.c" 3 4
__builtin_offsetof (
# 520 "../silver/A.c"
ident_f
# 520 "../silver/A.c" 3 4
, 
# 520 "../silver/A.c"
is_string
# 520 "../silver/A.c" 3 4
)
# 520 "../silver/A.c"
; ident_type.members[ident_type.member_count].member_type = A_TYPE_IMETHOD; ident_type.member_count++; ident_type . hash = & ident_hash;; A_push_type(&ident_type); return (bool)1; } }
# 534 "../silver/A.c"

# 534 "../silver/A.c"
#pragma pack(push, 1)
# 534 "../silver/A.c"
 typedef struct enode { EType etype; A value; array operands; array references; } *enode;
# 534 "../silver/A.c"
#pragma pack(pop)
# 534 "../silver/A.c"
 typedef struct enode_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(enode); none (*destructor)(enode); i32 (*compare)(enode,enode); u64 (*hash)(enode); bool (*boolean)(enode); A (*lookup)(array, ident, bool); string (*string_interpolate)(A, array); A (*exec)(enode, array); } enode_f; typedef struct enode_ctr { enode (*enode_default)(struct enode_f*, num); enode (*enode_create_operation)(struct enode_f*, num, EType, array, array); enode (*enode_create_value)(struct enode_f*, num, EType, A); enode (*enode_method_call)(struct enode_f*, num, ident, array); } enode_ctr; extern enode_ctr enode_new; extern enode_f enode_type;

enode enode_create_operation(EType etype, array ops, array references) {
    return ((void*)0);
}

enode enode_create_value(EType etype, A value) {
    return ((void*)0);
}

enode enode_method_call(EType etype, ident method, array args) {
    return ((void*)0);
}

A enode_lookup(array stack, ident id, bool top_only) {
    return ((void*)0);
}

string enode_string_interpolate(A input, array stack) {
    return ((void*)0);
}

A enode_exec(enode op, array stack) {
    return ((void*)0);
}

bool enode_boolean(enode a) {
    return a->etype != EType_Undefined;
}

enode_ctr enode_new; enode_f enode_type; static __attribute__((constructor)) bool global_enode() { enode_f* type_ref = &enode_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_enode); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(enode_type) / sizeof(void*)]; enode_type.parent = & A_type; enode_type.name = "enode"; enode_type.size = sizeof(struct enode); enode_type.members = members; enode_type.traits = 0; enode_type.arb = &ffi_type_pointer; enode_new . enode_create_operation = & enode_create_operation; 
# 564 "../silver/A.c" 3 4
((void) sizeof ((
# 564 "../silver/A.c"
"enode" == "enode"
# 564 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 564 "../silver/A.c"
"enode" == "enode"
# 564 "../silver/A.c" 3 4
) ; else __assert_fail (
# 564 "../silver/A.c"
"\"enode\" == \"enode\""
# 564 "../silver/A.c" 3 4
, "../silver/A.c", 564, __extension__ __PRETTY_FUNCTION__); }))
# 564 "../silver/A.c"
; enode_type.members[enode_type.member_count].name = "create_operation"; enode_type.members[enode_type.member_count].args = (args_t) { EXPAND_ARGS_array(AType, num, EType, array, array) }; enode_type.members[enode_type.member_count].type = &enode_type; enode_type.members[enode_type.member_count].offset = 
# 564 "../silver/A.c" 3 4
__builtin_offsetof (
# 564 "../silver/A.c"
enode_ctr
# 564 "../silver/A.c" 3 4
, 
# 564 "../silver/A.c"
enode_create_operation
# 564 "../silver/A.c" 3 4
)
# 564 "../silver/A.c"
; enode_type.members[enode_type.member_count].member_type = A_TYPE_CONSTRUCT; enode_type.member_count++; enode_new . enode_create_value = & enode_create_value; 
# 564 "../silver/A.c" 3 4
((void) sizeof ((
# 564 "../silver/A.c"
"enode" == "enode"
# 564 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 564 "../silver/A.c"
"enode" == "enode"
# 564 "../silver/A.c" 3 4
) ; else __assert_fail (
# 564 "../silver/A.c"
"\"enode\" == \"enode\""
# 564 "../silver/A.c" 3 4
, "../silver/A.c", 564, __extension__ __PRETTY_FUNCTION__); }))
# 564 "../silver/A.c"
; enode_type.members[enode_type.member_count].name = "create_value"; enode_type.members[enode_type.member_count].args = (args_t) { 4, &AType_type, &num_type, &EType_type, &A_type }; enode_type.members[enode_type.member_count].type = &enode_type; enode_type.members[enode_type.member_count].offset = 
# 564 "../silver/A.c" 3 4
__builtin_offsetof (
# 564 "../silver/A.c"
enode_ctr
# 564 "../silver/A.c" 3 4
, 
# 564 "../silver/A.c"
enode_create_value
# 564 "../silver/A.c" 3 4
)
# 564 "../silver/A.c"
; enode_type.members[enode_type.member_count].member_type = A_TYPE_CONSTRUCT; enode_type.member_count++; enode_new . enode_method_call = & enode_method_call; 
# 564 "../silver/A.c" 3 4
((void) sizeof ((
# 564 "../silver/A.c"
"enode" == "enode"
# 564 "../silver/A.c" 3 4
) ? 1 : 0), __extension__ ({ if (
# 564 "../silver/A.c"
"enode" == "enode"
# 564 "../silver/A.c" 3 4
) ; else __assert_fail (
# 564 "../silver/A.c"
"\"enode\" == \"enode\""
# 564 "../silver/A.c" 3 4
, "../silver/A.c", 564, __extension__ __PRETTY_FUNCTION__); }))
# 564 "../silver/A.c"
; enode_type.members[enode_type.member_count].name = "method_call"; enode_type.members[enode_type.member_count].args = (args_t) { 4, &AType_type, &num_type, &ident_type, &array_type }; enode_type.members[enode_type.member_count].type = &enode_type; enode_type.members[enode_type.member_count].offset = 
# 564 "../silver/A.c" 3 4
__builtin_offsetof (
# 564 "../silver/A.c"
enode_ctr
# 564 "../silver/A.c" 3 4
, 
# 564 "../silver/A.c"
enode_method_call
# 564 "../silver/A.c" 3 4
)
# 564 "../silver/A.c"
; enode_type.members[enode_type.member_count].member_type = A_TYPE_CONSTRUCT; enode_type.member_count++; enode_type . lookup = & enode_lookup; enode_type.members[enode_type.member_count].name = "lookup"; enode_type.members[enode_type.member_count].args = (args_t) { 3, &array_type, &ident_type, &bool_type }; enode_type.members[enode_type.member_count].type = &A_type; enode_type.members[enode_type.member_count].offset = 
# 564 "../silver/A.c" 3 4
__builtin_offsetof (
# 564 "../silver/A.c"
enode_f
# 564 "../silver/A.c" 3 4
, 
# 564 "../silver/A.c"
lookup
# 564 "../silver/A.c" 3 4
)
# 564 "../silver/A.c"
; enode_type.members[enode_type.member_count].member_type = A_TYPE_SMETHOD; enode_type.member_count++; enode_type . string_interpolate = & enode_string_interpolate; enode_type.members[enode_type.member_count].name = "string_interpolate"; enode_type.members[enode_type.member_count].args = (args_t) { 2, &A_type, &array_type }; enode_type.members[enode_type.member_count].type = &string_type; enode_type.members[enode_type.member_count].offset = 
# 564 "../silver/A.c" 3 4
__builtin_offsetof (
# 564 "../silver/A.c"
enode_f
# 564 "../silver/A.c" 3 4
, 
# 564 "../silver/A.c"
string_interpolate
# 564 "../silver/A.c" 3 4
)
# 564 "../silver/A.c"
; enode_type.members[enode_type.member_count].member_type = A_TYPE_SMETHOD; enode_type.member_count++; enode_type . exec = & enode_exec; enode_type.members[enode_type.member_count].name = "exec"; enode_type.members[enode_type.member_count].args = (args_t) { 2, &enode_type, &array_type }; enode_type.members[enode_type.member_count].type = &A_type; enode_type.members[enode_type.member_count].offset = 
# 564 "../silver/A.c" 3 4
__builtin_offsetof (
# 564 "../silver/A.c"
enode_f
# 564 "../silver/A.c" 3 4
, 
# 564 "../silver/A.c"
exec
# 564 "../silver/A.c" 3 4
)
# 564 "../silver/A.c"
; enode_type.members[enode_type.member_count].member_type = A_TYPE_IMETHOD; enode_type.member_count++; enode_type . boolean = & enode_boolean;; A_push_type(&enode_type); return (bool)1; } }
# 586 "../silver/A.c"

# 586 "../silver/A.c"
#pragma pack(push, 1)
# 586 "../silver/A.c"
 typedef struct Parser { array tokens; string fname; num cur; } *Parser;
# 586 "../silver/A.c"
#pragma pack(pop)
# 586 "../silver/A.c"
 typedef struct Parser_f { struct A_f* parent; char* name; num size; num member_count; member_t* members; u64 traits; void* arb; none (*init)(Parser); none (*destructor)(Parser); i32 (*compare)(Parser,Parser); u64 (*hash)(Parser); bool (*boolean)(Parser); ident (*token_at)(Parser, num); ident (*next)(Parser); ident (*pop)(Parser); num (*consume)(Parser); EType (*expect)(Parser, ident, array); EType (*is_alpha_ident)(Parser, ident); ident (*relative)(Parser, num); EType (*is_assign)(Parser, ident); enode (*parse_statements)(Parser); enode (*parse_expression)(Parser); enode (*parse_statement)(Parser); i64 (*parse_numeric)(Parser, ident); EType (*is_var)(Parser, ident); enode (*parse_add)(Parser); enode (*parse_mult)(Parser); enode (*parse_primary)(Parser); } Parser_f; typedef struct Parser_ctr { Parser (*Parser_default)(struct Parser_f*, num); } Parser_ctr; extern Parser_ctr Parser_new; extern Parser_f Parser_type;


array parse_tokens(string contents, string fname) {
    return ((void*)0);
}

static ident Parser_token_at(Parser a, num r) {
    return a->tokens->elements[a->cur + r];
}

static ident Parser_next(Parser a) {
    return ((Parser_f*)((A)a)[-1].type) -> token_at(a, 0);
}

static ident Parser_pop(Parser a) {
    if (a->cur < a->tokens->len)
        a->cur++;
    return a->tokens->elements[a->cur];
}

static num Parser_consume(Parser a) {
    ((Parser_f*)((A)a)[-1].type) -> consume(a);
    return a->cur;
}

static EType Parser_expect(Parser a, ident token, array tokens) {
    return ((array_f*)((A)tokens)[-1].type) -> index_of(tokens, token);
}

static EType Parser_is_alpha_ident(Parser a, ident token) {
    char t = token ? token->value->chars[0] : 0;
    return (
# 618 "../silver/A.c" 3 4
           ((*__ctype_b_loc ())[(int) ((
# 618 "../silver/A.c"
           t
# 618 "../silver/A.c" 3 4
           ))] & (unsigned short int) _ISalpha) 
# 618 "../silver/A.c"
                      && ((array_f*)((A)keywords)[-1].type) -> index_of(keywords, token) == -1) ?
        EType_AlphaIdent : EType_Undefined;
}

static ident Parser_relative(Parser a, num pos) {
    return a->tokens->elements[a->cur + pos];
}

static EType Parser_is_assign(Parser a, ident token) {
}

static enode Parser_parse_statements(Parser parser) {
}

static enode Parser_parse_expression(Parser parser) {
}

static enode Parser_parse_statement(Parser parser) {
}

static i64 Parser_parse_numeric(Parser parser, ident token) {
}

static EType Parser_is_var(Parser parser, ident) {
}

static enode Parser_parse_add(Parser parser) {
}

static enode Parser_parse_mult(Parser parser) {
}

static enode Parser_parse_primary(Parser parser) {
}


Parser parser_new(array tokens, string fname) {
    Parser parser = ((Parser)A_alloc(((struct A_f*)&Parser_type), 1));
    parser->tokens = hold(tokens);
    parser->fname = hold(fname);
    return parser;
}

Parser_ctr Parser_new; Parser_f Parser_type; static __attribute__((constructor)) bool global_Parser() { Parser_f* type_ref = &Parser_type; A_f* base_ref = &A_type; if ((A_t)type_ref != (A_t)base_ref && base_ref->size == 0) { A_lazy_init((global_init_fn)&global_Parser); return (bool)0; } else { memcpy(type_ref, base_ref, sizeof(A_f)); static member_t members[sizeof(Parser_type) / sizeof(void*)]; Parser_type.parent = & A_type; Parser_type.name = "Parser"; Parser_type.size = sizeof(struct Parser); Parser_type.members = members; Parser_type.traits = 0; Parser_type.arb = &ffi_type_pointer; Parser_type . token_at = & Parser_token_at; Parser_type.members[Parser_type.member_count].name = "token_at"; Parser_type.members[Parser_type.member_count].args = (args_t) { 2, &Parser_type, &num_type }; Parser_type.members[Parser_type.member_count].type = &ident_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
token_at
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . next = & Parser_next; Parser_type.members[Parser_type.member_count].name = "next"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &ident_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
next
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . pop = & Parser_pop; Parser_type.members[Parser_type.member_count].name = "pop"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &ident_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
pop
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . consume = & Parser_consume; Parser_type.members[Parser_type.member_count].name = "consume"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &num_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
consume
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . expect = & Parser_expect; Parser_type.members[Parser_type.member_count].name = "expect"; Parser_type.members[Parser_type.member_count].args = (args_t) { 3, &Parser_type, &ident_type, &array_type }; Parser_type.members[Parser_type.member_count].type = &EType_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
expect
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . is_alpha_ident = & Parser_is_alpha_ident; Parser_type.members[Parser_type.member_count].name = "is_alpha_ident"; Parser_type.members[Parser_type.member_count].args = (args_t) { 2, &Parser_type, &ident_type }; Parser_type.members[Parser_type.member_count].type = &EType_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
is_alpha_ident
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . relative = & Parser_relative; Parser_type.members[Parser_type.member_count].name = "relative"; Parser_type.members[Parser_type.member_count].args = (args_t) { 2, &Parser_type, &num_type }; Parser_type.members[Parser_type.member_count].type = &ident_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
relative
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . is_assign = & Parser_is_assign; Parser_type.members[Parser_type.member_count].name = "is_assign"; Parser_type.members[Parser_type.member_count].args = (args_t) { 2, &Parser_type, &ident_type }; Parser_type.members[Parser_type.member_count].type = &EType_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
is_assign
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_statements = & Parser_parse_statements; Parser_type.members[Parser_type.member_count].name = "parse_statements"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &enode_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
parse_statements
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_expression = & Parser_parse_expression; Parser_type.members[Parser_type.member_count].name = "parse_expression"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &enode_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
parse_expression
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_statement = & Parser_parse_statement; Parser_type.members[Parser_type.member_count].name = "parse_statement"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &enode_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
parse_statement
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_numeric = & Parser_parse_numeric; Parser_type.members[Parser_type.member_count].name = "parse_numeric"; Parser_type.members[Parser_type.member_count].args = (args_t) { 2, &Parser_type, &ident_type }; Parser_type.members[Parser_type.member_count].type = &i64_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
parse_numeric
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . is_var = & Parser_is_var; Parser_type.members[Parser_type.member_count].name = "is_var"; Parser_type.members[Parser_type.member_count].args = (args_t) { 2, &Parser_type, &ident_type }; Parser_type.members[Parser_type.member_count].type = &EType_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
is_var
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_add = & Parser_parse_add; Parser_type.members[Parser_type.member_count].name = "parse_add"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &enode_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
parse_add
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_mult = & Parser_parse_mult; Parser_type.members[Parser_type.member_count].name = "parse_mult"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &enode_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
parse_mult
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++; Parser_type . parse_primary = & Parser_parse_primary; Parser_type.members[Parser_type.member_count].name = "parse_primary"; Parser_type.members[Parser_type.member_count].args = (args_t) { 1, &Parser_type }; Parser_type.members[Parser_type.member_count].type = &enode_type; Parser_type.members[Parser_type.member_count].offset = 
# 661 "../silver/A.c" 3 4
__builtin_offsetof (
# 661 "../silver/A.c"
Parser_f
# 661 "../silver/A.c" 3 4
, 
# 661 "../silver/A.c"
parse_primary
# 661 "../silver/A.c" 3 4
)
# 661 "../silver/A.c"
; Parser_type.members[Parser_type.member_count].member_type = A_TYPE_IMETHOD; Parser_type.member_count++;; A_push_type(&Parser_type); return (bool)1; } }

int main(int argc, char **argv) {
    A_finish_types();


    keywords = ((array)A_alloc(((struct A_f*)&array_type), 1));
    ((array_f*)((A)keywords)[-1].type) -> push_symbols(keywords, "class", "proto", "struct", "import", "return", "asm", "if", "switch", "while", "for", "do", ((void*)0))


                                              ;

    string s = ((string)A_alloc(((struct A_f*)&string_type), 1));
    array a = ((array)A_alloc(((struct A_f*)&array_type), 1));
    ((array_f*)((A)a)[-1].type) -> push(a, hold(s));

    array args = ((array)A_alloc(((struct A_f*)&array_type), 1));
    array_f* a_type = &array_type;
    array array2 = ((array)array_new.array_with_cstr(((struct A_f*)&array_type), (num)(1), "test"));

    ((array_f*)((A)args)[-1].type) -> push(args, hold(a));
    ((array_f*)((A)args)[-1].type) -> push(args, hold(s));
    array_f* type = ((A_t)((A)a)[-1].type);

    A a_result = A_method(type, "push", args);

    
# 687 "../silver/A.c" 3 4
   ((void) sizeof ((
# 687 "../silver/A.c"
   ((A_t)((A)a_result)[-1].type) == ((struct A_f*)&none_type)
# 687 "../silver/A.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 687 "../silver/A.c"
   ((A_t)((A)a_result)[-1].type) == ((struct A_f*)&none_type)
# 687 "../silver/A.c" 3 4
   ) ; else __assert_fail (
# 687 "../silver/A.c"
   "typeid(a_result) == typeof(none)"
# 687 "../silver/A.c" 3 4
   , "../silver/A.c", 687, __extension__ __PRETTY_FUNCTION__); }))
# 687 "../silver/A.c"
                                           ;

    drop(args);
    drop(a_result);
    drop(s);
    return 0;
}
