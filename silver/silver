#ifndef _SILVER_
#define _SILVER_
#include <A>

// it will be nice to put parser logic outside silver, parse
// class used for module reading, parsing and llvm management.
// helps hide weird stuff

typedef struct silver* silver;

#define reference_schema(X,Y) \
    i_prop(    X,Y, intern, AType,  type) \
    i_prop(    X,Y, intern, num,    refs) \
    i_prop(    X,Y, intern, silver, module) \
    i_override(X,Y, method, init)
declare_class(reference)

#define ref(m, t, c) new(reference, type, t, refs, c, module, m)

#define function_schema(X,Y) \
    i_prop     (X,Y, intern, object, intern) \
    i_prop     (X,Y, public, cstr,   name) \
    i_prop     (X,Y, public, silver, module) \
    i_prop     (X,Y, public, AType,  rtype) \
    i_prop     (X,Y, public, array,  args) \
    i_override (X,Y, method, init)
declare_class(function)

#define silver_schema(X,Y)\
    i_prop    (X,Y, public, path,   install) \
    i_prop    (X,Y, public, path,   source) \
    i_prop    (X,Y, public, bool,   debug) \
    i_prop    (X,Y, intern, object, intern)\
    i_prop    (X,Y, intern, map,    defs) \
    i_prop    (X,Y, intern, string, source_file) \
    i_prop    (X,Y, intern, path,   source_path) \
    i_prop    (X,Y, intern, array,  main_symbols) \
    i_prop    (X,Y, intern, array,  compiled_objects) \
    i_prop    (X,Y, intern, array,  libraries_used) \
    i_override(X,Y, method, init) \
    i_override(X,Y, method, destructor)
declare_class(silver)

#endif