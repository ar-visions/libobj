#ifndef _SILVER_
#define _SILVER_

#include <llvm-c/DebugInfo.h>
#include <llvm-c/Core.h>
#include <llvm-c/ExecutionEngine.h>
#include <llvm-c/Target.h>
#include <llvm-c/Analysis.h>
#include <llvm-c/TargetMachine.h>
#include <llvm-c/BitWriter.h>
#include <clang-c/Index.h>

#include <A>

typedef struct silver* silver;
typedef struct dim*    dim;
typedef struct Token*  Token;
typedef struct type*   type;
typedef struct Tokens* Tokens;

#define Visibility_schema(X,Y) \
    enum_value(X,Y, undefined) \
    enum_value(X,Y, intern) \
    enum_value(X,Y, public)
declare_enum(Visibility)

#include <tokens>
#include <import>

/// models of C types
/// order primitives of precedence when combined
/// we would prefer f32 over u8 for example, and f32 over i64
#define model_schema(X,Y) \
    enum_value(X,Y, bool)  \
    enum_value(X,Y, u8)  \
    enum_value(X,Y, u16) \
    enum_value(X,Y, u32) \
    enum_value(X,Y, u64) \
    enum_value(X,Y, i8)  \
    enum_value(X,Y, i16) \
    enum_value(X,Y, i32) \
    enum_value(X,Y, i64) \
    enum_value(X,Y, f32) \
    enum_value(X,Y, f64) \
    enum_value(X,Y, cstr) \
    enum_value(X,Y, void) \
    enum_value(X,Y, union) \
    enum_value(X,Y, struct) \
    enum_value(X,Y, class) \
    enum_value(X,Y, function) \
    enum_value(X,Y, typedef)
declare_enum(model)

/// origin changed to allow for dim, so this means def alias i = int*  is possible
#define def_schema(X,Y) \
    i_prop(    X,Y, public,     Visibility,         visibility) \
    i_prop(    X,Y, public,     string,             name) \
    i_prop(    X,Y, public,     model,              mdl) \
    i_prop(    X,Y, public,     AType,              imported) \
    i_prop(    X,Y, public,     string,             from_include) \
    i_prop(    X,Y, public,     dim,                origin) \
    i_prop(    X,Y, public,     i32,                size) \
    i_prop(    X,Y, public,     map,                members) \
    i_prop(    X,Y, public,     silver,             mod) \
    i_prop(    X,Y, public,     Token,              token) \
    i_prop(    X,Y, intern,     LLVMTypeRef,        type) \
    i_prop(    X,Y, intern,     LLVMMetadataRef,    dbg) \
    i_override(X,Y, method,     init)
declare_class(def)

#define function_schema(X,Y) \
    i_prop(    X,Y, public,     bool,               va_args) \
    i_prop(    X,Y, public,     map,                args) \
    i_prop(    X,Y, public,     dim,                info) \
    i_prop(    X,Y, public,     dim,                rtype) \
    i_prop(    X,Y, public,     Tokens,             body) \
    i_prop(    X,Y, intern,     LLVMMetadataRef,    subproc) \
    i_prop(    X,Y, intern,     LLVMMetadataRef,    function) \
    i_prop(    X,Y, intern,     LLVMBasicBlockRef,  entry) \
    i_override(X,Y, method,     init)
declare_mod(function, def)

// y-u-so-dimm: greg during Baldeck's lecture on so-dimm
// select [wrap] based on the shape read
// mapping args could be nice to give here, 
// in the same way an array may allocate a size
// its a query for the wrap
// i cant bring myself to tweak this really.. but its annoying that a basic type model is a 'dim' and not 'type'
// having a 'type arrangement' a lame thing to put in middle, too, because then it gets shape and const, but not static
// we want a MAX of 2 things here

#define dim_schema(X,Y) \
    i_prop(    X,Y, public,     def,                def) \
    i_prop(    X,Y, public,     silver,             mod) \
    i_prop(    X,Y, public,     map,                context) \
    i_prop(    X,Y, intern,     string,             name) \
    i_prop(    X,Y, intern,     num,                depth) \
    i_prop(    X,Y, intern,     bool,               is_static) \
    i_prop(    X,Y, intern,     bool,               is_const) \
    i_prop(    X,Y, intern,     Visibility,         visibility) \
    i_prop(    X,Y, intern,     def,                wrap) \
    i_prop(    X,Y, intern,     array,              shape) \
    i_prop(    X,Y, intern,     bool,               cached) \
    i_prop(    X,Y, intern,     LLVMTypeRef,        type) \
    i_prop(    X,Y, intern,     LLVMValueRef,       value) \
    i_prop(    X,Y, intern,     LLVMMetadataRef,    dbg) \
    i_prop(    X,Y, public,     num,                line) \
    s_method(  X,Y, public,     dim,        read, silver, map, bool) \
    i_override(X,Y, method,     init)
declare_class(dim)

#define silver_schema(X,Y)\
    i_prop    (X,Y, required,   path,                 install) \
    i_prop    (X,Y, required,   path,                 source) \
    i_prop    (X,Y, intern,     LLVMModuleRef,        module) \
    i_prop    (X,Y, intern,     LLVMContextRef,       context) \
    i_prop    (X,Y, intern,     LLVMBuilderRef,       builder) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,      file) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,      compile_unit) \
    i_prop    (X,Y, intern,     LLVMDIBuilderRef,     dbg) \
    i_prop    (X,Y, intern,     LLVMMetadataRef,      scope) \
    i_prop    (X,Y, intern,     LLVMTargetRef,        target) \
    i_prop    (X,Y, intern,     LLVMTargetDataRef,    target_data) \
    i_prop    (X,Y, intern,     LLVMTargetMachineRef, target_machine) \
    i_prop    (X,Y, intern,     array,                scope_stack) \
    i_prop    (X,Y, intern,     cstr,                 target_triple) \
    i_prop    (X,Y, intern,     array,                imports) \
    i_prop    (X,Y, intern,     Tokens,               tokens) \
    i_prop    (X,Y, intern,     array,                member_stack) \
    i_prop    (X,Y, intern,     map,                  defs) \
    i_prop    (X,Y, intern,     map,                  members) \
    i_prop    (X,Y, intern,     string,               source_file) \
    i_prop    (X,Y, intern,     path,                 source_path) \
    i_prop    (X,Y, intern,     array,                main_symbols) \
    i_prop    (X,Y, intern,     array,                compiled_objects) \
    i_prop    (X,Y, intern,     array,                libraries_used) \
    i_prop    (X,Y, intern,     map,                  include) \
    i_prop    (X,Y, intern,     map,                  type_refs) \
    i_prop    (X,Y, intern,     map,                  operators) \
    i_prop    (X,Y, intern,     int,                  expr_level) \
    i_prop    (X,Y, intern,     string,               current_include) \
    i_prop    (X,Y, public,     bool,                 debug) \
    i_method  (X,Y, public,     none,                 write) \
    i_method  (X,Y, public,     path,                 source_path) \
    i_override(X,Y, method,     init) \
    i_override(X,Y, method,     destructor)
declare_class(silver)


/// for imported handles we can register the type
#define LLVMValueRef_schema(X,Y) raw_schema(X,Y)
declare_primitive(LLVMValueRef, raw)

#endif