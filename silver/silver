#ifndef _SILVER_
#define _SILVER_
#include <A>

// it will be nice to put parser logic outside 
// silver, parse class used for module reading,
// parsing and llvm management. helps hide weird stuff

typedef struct silver* silver;
typedef struct dim*    dim;
typedef struct Token*  Token;
typedef struct type*   type;
typedef struct Tokens* Tokens;

/// models of C types
/// order primitives of precedence when combined
/// we would prefer f32 over u8 for example, and f32 over i64
#define model_schema(X,Y) \
    enum_value(X,Y, bool)  \
    enum_value(X,Y, u8)  \
    enum_value(X,Y, u16) \
    enum_value(X,Y, u32) \
    enum_value(X,Y, u64) \
    enum_value(X,Y, i8)  \
    enum_value(X,Y, i16) \
    enum_value(X,Y, i32) \
    enum_value(X,Y, i64) \
    enum_value(X,Y, f32) \
    enum_value(X,Y, f64) \
    enum_value(X,Y, cstr) \
    enum_value(X,Y, void) \
    enum_value(X,Y, union) \
    enum_value(X,Y, struct) \
    enum_value(X,Y, class) \
    enum_value(X,Y, function) \
    enum_value(X,Y, typedef)
declare_enum(model)

#define Visibility_schema(X,Y) \
    enum_value(X,Y, undefined) \
    enum_value(X,Y, intern) \
    enum_value(X,Y, public)
declare_enum(Visibility)

#define type_schema(X,Y) \
    i_prop(    X,Y, intern, object,     intern) \
    i_prop(    X,Y, public, string,     name) \
    i_prop(    X,Y, public, model,      mdl) \
    i_prop(    X,Y, public, AType,      imported) \
    i_prop(    X,Y, public, A,          rtype) \
    i_prop(    X,Y, public, map,        args) \
    i_prop(    X,Y, public, type,       origin) \
    i_prop(    X,Y, public, i32,        size) \
    i_prop(    X,Y, public, map,        members) \
    i_prop(    X,Y, public, silver,     module) \
    i_prop(    X,Y, public, Token,      token) \
    i_prop(    X,Y, public, A,          info) \
    i_prop(    X,Y, intern, Tokens,     body) \
    i_method(  X,Y, public, dim,        find_member) \
    i_override(X,Y, method, init)
declare_class(type)

// y-u-so-dimm: greg during Baldeck's lecture on so-dimm
// select [wrap] based on the shape read
// mapping args could be nice to give here, 
// in the same way an array may allocate a size
// its a query for the wrap
#define dim_schema(X,Y) \
    i_prop(    X,Y, intern,   A,          intern) \
    i_prop(    X,Y, public,   type,       type) \
    i_prop(    X,Y, public,   bool,       parse) \
    i_prop(    X,Y, required, silver,     module) \
    i_prop(    X,Y, required, map,        context) \
    i_prop(    X,Y, intern,   string,     name) \
    i_prop(    X,Y, intern,   num,        depth) \
    i_prop(    X,Y, intern,   bool,       is_static) \
    i_prop(    X,Y, intern,   Visibility, visibility) \
    i_prop(    X,Y, intern,   type,       wrap) \
    i_prop(    X,Y, intern,   array,      shape) \
    i_prop(    X,Y, intern,   bool,       cached) \
    s_method(  X,Y, public,   dim,        parse, silver, map) \
    i_override(X,Y, method,   init)
declare_class(dim)

#define module_def(m, n)   call0(m->defs, get, str(n))

#define silver_schema(X,Y)\
    i_prop    (X,Y, required, path,       install) \
    i_prop    (X,Y, required, path,       source) \
    i_prop    (X,Y, public,   bool,       debug) \
    i_prop    (X,Y, intern,   object,     intern)\
    i_method  (X,Y, public,   path,       source_path) \
    i_method  (X,Y, public,   type,       get_type, string) \
    i_override(X,Y, method,   init) \
    i_override(X,Y, method,   destructor)
declare_class(silver)

#endif